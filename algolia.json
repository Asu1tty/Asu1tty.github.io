
[
  
  
  {
    "objectID": "1745572896",
    "permalink": "/post/rc4/",
    "title": "RC4原理及代码实现",
    
    "content": "在密码学中，RC4（Rivest Cipher 4，也称为 ARC4 或 ARCFOUR， 意思是Alleged（所谓的） RC4，见下文）是一种流密码 。虽然它在软件中以其简单性和速度而著称，但在 RC4 中发现了多个漏洞，使其不安全。 流密码（streamcipher）是对数据流进行连续处理的一类密码算法。流密码中一般以1比特、8比特或32比特等为单位进行加密和解密。其中RC4的加解密单位为8比特，也就是一个字节。\n1. 密码学中为什么经常使用异或？ 在密码学中经常使用异或运算，RC4的原理也依赖异或运算。 下面解释摘自《图解密码技术 第三版》\n由于两个相同的数进行XOR运算的结果一定为0，因此如果将A⊕B的结果再与B进行XOR运算，则结果会变回A。也就是说，两个公式中的B会相互抵消。\n将明文A用密钥B进行加密，得到密文A⊕B 将密文A⊕B用密钥B进行解密，得到明文A 图片摘自《图解密码技术 第三版》 从图中可以看出，执行一次蒙版操作后，原来的图像被隐藏（掩盖）了，而执行两次蒙版操作后，就又可以得到原来的图像了。 如果所使用的蒙版是完全随机的比特序列，则使用XOR就可以将原来的图像掩盖起来。但如果蒙版中的比特序列的排列是可以被推测出来的，那么实质上图像就没有被真正掩盖。对于密码技术来说，“是否可以预测”是非常重要的一点。能够产生不可预测的比特序列，对于密码技术的贡献是巨大的。这种不可预测的比特序列就称为随机数。\n2. 算法实现过程 2.1. KSA(key-scheduling algorithm) 使用密钥调度算法(key-scheduling algorithm)\n输入：一个可变长度的密钥（通常8-2048位）。 输出：一个256字节的置换数组S（S[0]到S[255]）。 2.1.1. 第一步 先初始化256字节的数组S，填充0到255的整数，即S[0]=0, S[1]=1, \u0026hellip;, S[255]=255。\n2.1.2. 第二步 创建一个临时数组T，长度与密钥相同，将密钥循环填充到T中（如果密钥长度不足256字节，则重复密钥）。\n2.1.3. 第三步 使用以下伪代码进行置换\nfor i = 0 to 255 j = (j + S[i] + T[i]) mod 256 swap S[i] and S[j] S数组被打乱，形成一个基于密钥的伪随机置换表。这样处理之后，就得到了介绍中提到的不可预测的比特序列\n2.2. PRGA(pseudo-random generation algorithm) 使用伪随机生成算法生成比特流。\n输入：初始化后的S数组，待加密/解密的明文/密文。 输出：与明文/密文等长的密钥流（keystream）。 初始化两个变量i和j为0，执行以下伪代码 i = (i + 1) mod 256 j = (j + S[i]) mod 256 swap S[i] and S[j] t = (S[i] + S[j]) mod 256 output S[t] 生成与输入明文/密文等长的密钥流。\n3. 密文与明文关系 根据前面的介绍可以得到如下关系\n将生成的密钥流与明文逐字节进行异或(XOR)操作，得到密文： 密文[i] = 明文[i] XOR 密钥流[i] 解密过程相同，因为XOR是可逆的： 明文[i] = 密文[i] XOR 密钥流[i] 4. 代码实现 Python\n#!/usr/bin/env python # -*- coding: utf-8 -*- # author: @manojpandey # Python 3 implementation for RC4 algorithm # Brief: https://en.wikipedia.org/wiki/RC4 # Will use codecs, as \u0026#39;str\u0026#39; object in Python 3 doesn\u0026#39;t have any attribute \u0026#39;decode\u0026#39; import codecs MOD = 256 def KSA(key): \u0026#39;\u0026#39;\u0026#39; Key Scheduling Algorithm (from wikipedia): for i from 0 to 255 S[i] := i endfor j := 0 for i from 0 to 255 j := (j + S[i] + key[i mod keylength]) mod 256 swap values of S[i] and S[j] endfor \u0026#39;\u0026#39;\u0026#39; key_length = len(key) # create the array \u0026#34;S\u0026#34; S = list(range(MOD)) # [0,1,2, ... , 255] j = 0 for i in range(MOD): j = (j + S[i] + key[i % key_length]) % MOD S[i], S[j] = S[j], S[i] # swap values return S def PRGA(S): \u0026#39;\u0026#39;\u0026#39; Psudo Random Generation Algorithm (from wikipedia): i := 0 j := 0 while GeneratingOutput: i := (i + 1) mod 256 j := (j + S[i]) mod 256 swap values of S[i] and S[j] K := S[(S[i] + S[j]) mod 256] output K endwhile \u0026#39;\u0026#39;\u0026#39; i = 0 j = 0 while True: i = (i + 1) % MOD j = (j + S[i]) % MOD S[i], S[j] = S[j], S[i] # swap values K = S[(S[i] + S[j]) % MOD] yield K def get_keystream(key): \u0026#39;\u0026#39;\u0026#39; Takes the encryption key to get the keystream using PRGA return object is a generator \u0026#39;\u0026#39;\u0026#39; S = KSA(key) return PRGA(S) def encrypt_logic(key, text): \u0026#39;\u0026#39;\u0026#39; :key -\u0026gt; encryption key used for encrypting, as hex string :text -\u0026gt; array of unicode values/ byte string to encrpyt/decrypt \u0026#39;\u0026#39;\u0026#39; # For plaintext key, use this key = [ord(c) for c in key] # If key is in hex: # key = codecs.decode(key, \u0026#39;hex_codec\u0026#39;) # key = [c for c in key] keystream = get_keystream(key) res = [] for c in text: val = (\u0026#34;%02X\u0026#34; % (c ^ next(keystream))) # XOR and taking hex res.append(val) return \u0026#39;\u0026#39;.join(res) def encrypt(key, plaintext): \u0026#39;\u0026#39;\u0026#39; :key -\u0026gt; encryption key used for encrypting, as hex string :plaintext -\u0026gt; plaintext string to encrpyt \u0026#39;\u0026#39;\u0026#39; plaintext = [ord(c) for c in plaintext] return encrypt_logic(key, plaintext) def decrypt(key, ciphertext): \u0026#39;\u0026#39;\u0026#39; :key -\u0026gt; encryption key used for encrypting, as hex string :ciphertext -\u0026gt; hex encoded ciphered text using RC4 \u0026#39;\u0026#39;\u0026#39; ciphertext = codecs.decode(ciphertext, \u0026#39;hex_codec\u0026#39;) res = encrypt_logic(key, ciphertext) return codecs.decode(res, \u0026#39;hex_codec\u0026#39;).decode(\u0026#39;utf-8\u0026#39;) def main(): key = \u0026#39;not-so-random-key\u0026#39; # plaintext plaintext = \u0026#39;Good work! Your implementation is correct\u0026#39; # plaintext # encrypt the plaintext, using key and RC4 algorithm ciphertext = encrypt(key, plaintext) print(\u0026#39;plaintext:\u0026#39;, plaintext) print(\u0026#39;ciphertext:\u0026#39;, ciphertext) # .. # Let\u0026#39;s check the implementation # .. ciphertext = \u0026#39;2D7FEE79FFCE80B7DDB7BDA5A7F878CE298615\u0026#39;\\ \u0026#39;476F86F3B890FD4746BE2D8F741395F884B4A35CE979\u0026#39; # change ciphertext to string again decrypted = decrypt(key, ciphertext) print(\u0026#39;decrypted:\u0026#39;, decrypted) if plaintext == decrypted: print(\u0026#39;\\nCongrats ! You made it.\u0026#39;) else: print(\u0026#39;Shit! You pooped your pants ! .-.\u0026#39;) # until next time folks ! def test(): # Test case 1 # key = \u0026#39;4B6579\u0026#39; # \u0026#39;Key\u0026#39; in hex # key = \u0026#39;Key\u0026#39; # plaintext = \u0026#39;Plaintext\u0026#39; # ciphertext = \u0026#39;BBF316E8D940AF0AD3\u0026#39; assert(encrypt(\u0026#39;Key\u0026#39;, \u0026#39;Plaintext\u0026#39;)) == \u0026#39;BBF316E8D940AF0AD3\u0026#39; assert(decrypt(\u0026#39;Key\u0026#39;, \u0026#39;BBF316E8D940AF0AD3\u0026#39;)) == \u0026#39;Plaintext\u0026#39; # Test case 2 # key = \u0026#39;Wiki\u0026#39; # \u0026#39;57696b69\u0026#39;in hex # plaintext = \u0026#39;pedia\u0026#39; # ciphertext should be 1021BF0420 assert(encrypt(\u0026#39;Wiki\u0026#39;, \u0026#39;pedia\u0026#39;)) == \u0026#39;1021BF0420\u0026#39; assert(decrypt(\u0026#39;Wiki\u0026#39;, \u0026#39;1021BF0420\u0026#39;)) == \u0026#39;pedia\u0026#39; # Test case 3 # key = \u0026#39;Secret\u0026#39; # \u0026#39;536563726574\u0026#39; in hex # plaintext = \u0026#39;Attack at dawn\u0026#39; # ciphertext should be 45A01F645FC35B383552544B9BF5 assert(encrypt(\u0026#39;Secret\u0026#39;, \u0026#39;Attack at dawn\u0026#39;)) == \u0026#39;45A01F645FC35B383552544B9BF5\u0026#39; assert(decrypt(\u0026#39;Secret\u0026#39;, \u0026#39;45A01F645FC35B383552544B9BF5\u0026#39;)) == \u0026#39;Attack at dawn\u0026#39; if __name__ == \u0026#39;__main__\u0026#39;: main() ",
    
    "date": "2025-04-25 17:21:36",
    "updated": "2025-04-25 17:21:36"
  }
  
  , 
  {
    "objectID": "1745500236",
    "permalink": "/post/wb_aes/",
    "title": "AES原理及白盒AES的DFA攻击",
    
    "content": "AES（Advanced Encryption Standard） 高级加密标准是 Rijndael 分组密码 的一种变体，由两位密码学家 Joan Daemen 和 Vincent Rijmen 开发，他们在 AES 选择过程中向 NIST 提交了一份提案Rijndael 是一系列具有不同密钥和块大小的密码。对于 AES，NIST 选择了 Rijndael 家族的三个成员，每个成员的块大小为 128 位，但有三种不同的密钥长度：128、192 和 256 位。\n1. AES分类 分类 密钥长度 轮密钥长度 扩展密钥长度 分组长度 加密轮数 AES-128 16字节 16字节 16*11=172 16字节 10 AES-192 24字节 16字节 16*13=208 16字节 12 AES-256 32字节 16字节 16*15=240 16字节 14 AES 128 192 256 除了密钥编排算法不一样和加密轮数不一样 其余的计算逻辑相同\nAES 128 192 256 CBC 模式IV的长度都是16个字节 CBC计算逻辑相同\nAES-128 密钥编排中K0是原始密钥 共16个字节\nAES-192 密钥编排中K0和K1前半部分是原始密钥 共24个字节\nAES-256 密钥编排中K0和K1是原始密钥 共32个字节\n如非特别说明，下面加密介绍中AES都以AES-128为例\n2. PKCS填充方式 PKCS5填充字符串由一个1~8位的字节序列组成，每个字节填充该字节序列的长度 PKCS7（95% 都是PKCS7）填充字符串由一个1-255位的字节序列组成，每个字节填充该字节序列的长度 比如 AES-128的数据块长度是 16bytes，使用PKCS7进行填充时，填充的长度范围是 1 ~ 16\n示例一： 数据： FF FF FF FF FF FF FF FF FF\nPKCS5 填充： FF FF FF FF FF FF FF FF FF 07 07 07 07 07 07 07 PKCS7 填充： FF FF FF FF FF FF FF FF FF 07 07 07 07 07 07 07 示例二：\n数据： FF FF FF FF FF FF FF FF FF FF\nPKCS5 填充： FF FF FF FF FF FF FF FF FF FF 06 06 06 06 …",
    
    "date": "2025-04-24 21:10:36",
    "updated": "2025-04-24 21:10:36"
  }
  
  , 
  {
    "objectID": "1745466336",
    "permalink": "/post/mhac/",
    "title": "HMAC原理及代码实现",
    
    "content": "HMAC（Hash-based Message Authentication Code，散列消息认证码）是一种使用密码散列函数，同时结合一个加密密钥，通过特别计算方式之后产生的消息认证码（MAC）。 HMAC算法利用哈希运算，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。 hmac算法通常需要以一个hash函数为载体,比如常见的有hmacMd5,hmacSha1,hmacSha256,目前在so里只见到过hmacMd5,hmacSha256,但是hmac的规则是适用所有hash函数的\nHMAC算法的数学公式为： 其中：\nH 为密码Hash函数（如MD5或SHA-2)，能够对明文进行分组循环压缩；\nK 为密钥（secret key）；\nm 为要认证的消息；\nK’ 是从原始密钥 k 导出的另一个密钥（如果 k 短于散列函数的输入块大小，则向右填充零；如果比该块大小更长，则对 k 进行散列）；\nipad 内部填充（0x5C5C5C…5C5C，一段十六进制常量）；\nopad 外部填充（0x363636…3636，一段十六进制常量)；\n⊕：按位异或运算。\n||：字符串拼接。\n总结8个字就是:两次加盐,两次hash。\n1. 算法实现过程 HMAC需要选择一个哈希函数作为实现的载体，这里以MD5为例\n1.1. 第一步：扩展密钥 以字符串admin为例，十六进制如下\n61 64 6D 69 6E 填充密钥到64字节\n61 64 6D 69 6E 00(填充59次) 1.2. 异或0x36 将密钥逐字节异或0x36，得到扩展密钥1，0x36十进制是54\n57 52 5b 5f 58 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 1.3. 异或0x5C 将密钥逐字节异或0x5c，得到扩展密钥2，0x54十进制是92\n3d 38 31 35 32 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 1.4. 计算，两次加盐，两次哈希 1.4.1. 第一次加盐 扩展密钥1+输入,假设输入是hello,68 65 6c 6c 6f\n57 52 5b 5f 58 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 68 65 6c 6c 6f 1.4.2. 第一次哈希 上面提到，我们选择了MD5作为载体，那么对上面的数据进行一次MD5计算\n5511e8d27f4692a69a4f6cfebbac574b 1.4.3. 第二次加盐 扩展密钥2+第一次哈希的结果\n3d 38 31 35 32 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 55 11 e8 d2 7f 46 92 a6 9a 4f 6c fe bb ac 57 4b 1.4.4. 第二次哈希 对上面的输入进行一次MD5计算\n83e029bbdf98117cafe2b973ab8a4a0f 验证成功\n2. 代码实现 Python\nimport hashlib import hmac key1 = \u0026#39;57525b5f583636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636\u0026#39; key2 = \u0026#39;3d383135325c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c\u0026#39; inputStr = \u0026#39;hello\u0026#39; str1 = bytes.fromhex(key1) + inputStr.encode() # 第一次加盐 sign1 = hashlib.md5(str1).hexdigest() # 第一次hash print(\u0026#39;sign1\u0026#39;,sign1) str2 = bytes.fromhex(key2) + bytes.fromhex(sign1) # 第二次加盐 sign2 = hashlib.md5(str2).hexdigest() # # 第二次hash print(\u0026#39;sign2\u0026#39;,sign2) sign = hmac.new(\u0026#39;admin\u0026#39;.encode(), \u0026#39;hello\u0026#39;.encode(), hashlib.md5).hexdigest() print(\u0026#39;sign\u0026#39;,sign) ",
    
    "date": "2025-04-24 11:45:36",
    "updated": "2025-04-24 11:45:36"
  }
  
  , 
  {
    "objectID": "1745413836",
    "permalink": "/post/sha-512/",
    "title": "SHA-512简介及代码实现",
    
    "content": " 1. 算法 SHA-512在app逆向中遇到得很少，所以只作简单介绍 SHA-1可以生成一个被称为消息摘要的512位（64字节）散列值，散列值通常的呈现形式为128个十六进制数。与MD5，SHA1，SHA256不同的是，分组长度为1024位。表示消息长度为128位\n2. 算法实现过程 2.1. 填充 以字符串admin为例，十六进制如下\n61 64 6D 69 6E 首先需要填充到128字节，即先添加一个“1”，再后跟多个“0”，然后再追加一个128位的消息长度信息 第一位填充 0x80 剩下的填充 0 直到达到 112 个字节 填充K个“0”，所不同的是消息分组的长度是1024位，所以K的取值必须是满足下述表达式的最小非负整数值。 ( L + 1 + K ) mod 1024 = 896\n61 64 6D 69 6E 80 0(填充106次) 共 112 个字节 对比md5,sha1,sha256填充都是64字节分组,sha512是128字节分组,原因就在于无论是iv还是k都是8字节的,所以数据块也是8字节的\nsha512 H = [ 0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1, 0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179 ] sha256 H = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 ] sha512的高4字节是sha256的4字节,同理k表也是这样\n",
    
    "date": "2025-04-23 21:10:36",
    "updated": "2025-04-23 21:10:36"
  }
  
  , 
  {
    "objectID": "1745399690",
    "permalink": "/post/sha-256/",
    "title": "SHA-256原理及代码实现",
    
    "content": "SHA256是SHA-2下细分出的一种算法 SHA-2，名称来自于安全散列算法2（英语：Secure Hash Algorithm 2）的缩写，一种密码散列函数算法标准，由美国国家安全局研发，属于SHA算法之一，是SHA-1的后继者。 SHA-2下又可再分为六个不同的算法标准 包括了：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。 SHA-1可以生成一个被称为消息摘要的256位（32字节）散列值，散列值通常的呈现形式为64个十六进制数。\n1. 算法实现过程 1.1. 第一步：填充 以字符串admin为例，十六进制如下\n61 64 6D 69 6E 首先需要填充到64字节 第一位填充 0x80 剩下的填充 0 直到达到 56 个字节\n61 64 6D 69 6E 80 0(填充50次) 共 56 个字节 接下来 8 个字节 第一位填充消息长度 * 8，也就是5 * 8 = 40 = 0x28\n61 64 6D 69 6E 80 0(填充50次) 0(填充7次) 0x28 共 64 个字节 sha-256和sha-1的填充一样,对比md5,sha-1,sha-256,填充几乎都一样,唯一不同之处就是md5的附加消息长度是小端序,其余两个是大端序。\n1.2. 第二步：扩充 需要将16个四字节扩充至64个四字节 前16个四字节复制填充后的16个四字节 后48个四字节使用扩充算法进行扩充 sha256 for i in range(16, 64): s0 = right_rotate(W[i-15], 7) ^ right_rotate(W[i-15], 18) ^ (W[i-15] \u0026amp;gt;\u0026amp;gt; 3) s1 = right_rotate(W[i-2], 17) ^ right_rotate(W[i-2], 19) ^ (W[i-2] \u0026amp;gt;\u0026amp;gt; 10) W[i] = (W[i-16] + s0 + W[i-7] + s1) \u0026amp;amp; 0xffffffff sha1 for j in range(16, 80): w[j] = left_rotate(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1) 和sha-1的区别在于sha-1扩展64 …",
    
    "date": "2025-04-23 17:14:50",
    "updated": "2025-04-23 17:14:50"
  }
  
  , 
  {
    "objectID": "1745386116",
    "permalink": "/post/sha-1/",
    "title": "SHA-1原理及代码实现",
    
    "content": "SHA-1（英語：Secure Hash Algorithm 1，中文名：安全散列算法1）是一种密码散列函数，美国国家安全局设计。SHA-1可以生成一个被称为消息摘要的160位（20字节）散列值，散列值通常的呈现形式为40个十六进制数。\n1. 算法实现过程 1.1. 第一步：填充 以字符串admin为例，十六进制如下\n61 64 6D 69 6E 需要让它填充到64个字节长度\n第一位填充 0x80 剩下的填充 0 直到达到 56 个字节\n61 64 6D 69 6E 80 0(填充50次) 共 56 个字节 接下来 8 个字节 消息长度 * 8，也就是5 * 8 = 40 = 0x28\n61 64 6D 69 6E 80 0(填充50次) 0(填充7次) 0x28 共 64 个字节 填充这块唯一和md5有区别的就是,最后的附加消息长度是大端续,也就是正常的顺序 64字节的分组长度,md5,sha1,sha256都是, sha512是128字节分组。\n1.2. 第二步：扩充 sha1有80轮循环,每一轮要用不同的数据,而填充后的最多只有16个4字节数据,所以需要进行扩展\n前16个四字节复制填充后的16个四字节 后64个四字节使用扩充算法进行扩充 当前位置值 =（ 前面第3个四字节 ^ 前面第8个四字节 ^ 前面第14个四字节 ^ 前面第16个四字节 ）\u0026amp;laquo; 1\n\u0026amp;laquo; 代表循环左移 用代码表示\n# 扩展到80个字 for j in range(16, 80): w[j] = left_rotate(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1) 以字符串admin为例，扩充如下\n0x61646D69 0x6E800000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000028 0xC2C8DAD2 0xDD000000 0x00000050 0x8591B5A5 0xBA000001 0x000000A0 0x0B236B4B 0x74000053 …",
    
    "date": "2025-04-23 13:28:36",
    "updated": "2025-04-23 13:28:36"
  }
  
  , 
  {
    "objectID": "1745380130",
    "permalink": "/post/md5/",
    "title": "MD5原理及代码实现",
    
    "content": "MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16个字节）的散列值（hash value），用于确保资讯传输完整一致。 将数据（如一段文字）运算变为另一固定长度值，是散列算法的基础原理。\n1. 算法 MD5是输入不定长度，输出固定长度128-bits的算法。经过程序流程，生成四个32位数据，最后联合起来成为一个128-bits（16字节，通常消息传输中更常见表示为32 个十六进制字符）散列。\n2. 算法实现过程 2.1. 第一步：填充 MD5 的输入数据需要满足以下条件：\n数据长度（以位为单位）模 512 等于 448（即模 64 字节等于 56 字节）。 填充后，数据长度必须是 512 位的倍数（即 64 字节的倍数）。 以字符串admin为例，十六进制如下\n61 64 6D 69 6E 首先需要填充到64字节 第一位填充 0x80 剩下的填充 0 直到达到 56 个字节\n61 64 6D 69 6E 80 0(填充50次) 共 56 个字节 接下来 8 个字节 第一位填充消息长度 * 8，也就是5 * 8 = 40 = 0x28，（0x28 \u0026amp;amp; 0xFF）剩下的填充0\n61 64 6D 69 6E 80 0(填充50次) 0x28 0(填充7次) 共 64 个字节 2.1.1. 当输入大小恰好为56字节时 理论上，只需添加 0x80 和长度信息即可，但由于 0x80 占用 1 字节，剩余空间不足以容纳 8 字节的长度信息，因此需要填充到下一个 512 位块。\n在数据末尾添加 0x80（二进制 10000000），占用 1 字节。 当前长度：56 字节 + 1 字节 = 57 字节（456 位）。 因此，填充到下一个 512 位块（128 字节 = 1024 位）\n目标长度（不含长度信息）：128 字节 - 8 字节 = 120 字节。 当前长度：57 字节。 需要填充：120 字节 - 57 字节 = 63 字节。 填充 63 个 0x00 字节。 再在尾部加上消息长度信息，原始数据长度：56 × 8 = 448 位。用 64 位表示：0x000001C0（低位在前），填充为 8 字节：0xC0010000 00000000。 那么当输入大小大于56字节且小 …",
    
    "date": "2025-04-23 11:48:50",
    "updated": "2025-04-23 11:48:50"
  }
  
  , 
  {
    "objectID": "1654776772",
    "permalink": "/post/main/",
    "title": "Markdown Basic Elements",
    
    "content": " Markdown 基本元素 标题 H1 H2 H3 H4 H5 H6 强调 Emphasis, aka italics, with asterisks or underscores.\nStrong emphasis, aka bold, with asterisks or underscores.\nCombined emphasis with asterisks and underscores.\nStrikethrough uses two tildes. Scratch this.\n列表 Definition List (dl) Ordered List (ol) List Item 1 List Item 2 List Item 3 Unordered List (ul) List Item 1 List Item 2 List Item 3 段落 Lorem ipsum dolor sit amet, test link consectetur adipiscing elit. Strong text pellentesque ligula commodo viverra vehicula. Italic text at ullamcorper enim. Morbi a euismod nibh. Underline text non elit nisl. Deleted text tristique, sem id condimentum tempus, metus lectus venenatis mauris, sit amet semper lorem felis a eros. Fusce egestas nibh at sagittis auctor. Sed ultricies ac arcu quis molestie. Donec dapibus nunc in nibh egestas, vitae volutpat sem iaculis. Curabitur sem tellus, elementum nec quam id, fermentum laoreet mi. Ut mollis ullamcorper turpis, vitae facilisis velit ultricies sit amet. Etiam …",
    
    "date": "2022-06-09 20:12:52",
    "updated": "2022-06-09 20:12:52"
  }
  
]