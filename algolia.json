
[
  
  
  {
    "objectID": "1745983116",
    "permalink": "/post/elfreader/",
    "title": "ELF结构及加载流程分析",
    
    "content": " 目前，PC平台流行的 可执行文件格式（Executable） 主要包含如下两种：\nWindows下的 PE（Portable Executable） Linux下的 ELF（Executable Linkable Format） ELF（Executable and Linkable Format，可执行和可链接格式）是Linux系统中广泛使用的文件格式，用于存储可执行文件、目标代码、共享库和核心转储（core dump）。它是一种灵活、通用的格式，支持多种处理器架构和操作系统，具有跨平台特性。\n主要特点：\n跨平台支持：ELF支持多种处理器架构（如x86、x86_64、ARM、MIPS）和字节序（大端/小端）。 模块化设计：分为多个段（Section）和节（Segment），便于解析和操作。 支持动态链接：允许在运行时加载共享库，减少内存占用。 可扩展性：支持添加自定义段，适应不同需求。 ELF文件可以是以下几种类型：\n可执行文件（Executable File）：如编译后的程序，直接运行。 目标文件（Object File）：编译器生成的中间文件，通常用于链接生成可执行文件。 共享库（Shared Library）：动态链接库，运行时加载（如.so文件）。 核心转储（Core Dump）：程序崩溃时保存的内存快照，用于调试。 1. ELF主要结构 ELF 文件主要分为 3 个部分:\nELF Header ELF文件头，位于ELF文件的开头，描述文件的整体信息。它的大小通常为32位系统中的52字节或64位系统中的64字节。 Program Header Table 程序头表 ，描述了文件中的段（Segment），主要用于运行时加载和执行。 Section Header Table 节头表 ，描述了文件中的节（Section），主要用于链接和调试。每个节包含特定类型的数据（如代码、数据、符号表等）。节头表对于可执行文件是可选的，但在目标文件中通常存在。 1.1. ELF Header ELF文件头 //https://github.com/bminor/glibc/blob/glibc-2.27/elf/elf.h typedef struct { unsigned char\te_ident[EI_NIDENT];\t/* Magic number and other …",
    
    "date": "2025-04-30 11:18:36",
    "updated": "2025-04-30 11:18:36"
  }
  
  , 
  {
    "objectID": "1745574516",
    "permalink": "/post/xhs_analysis/",
    "title": "某红薯shield参数分析",
    
    "content": "版本：8.70.0\n1. 加密入口 加密入口在com.xingin.shield.http.XhsHttpInterceptor\njadx打开发现有如下Native层函数，intercept为拦截器，hook拦截器，并且打印chain.request()中的参数会发现传入前没有shield参数，执行完后有shield参数，正是在此Native层拦截器完成加密，并且通过函数名称也能猜测到so层有初始化操作\n在jadx反编译中并没有看到加载so的字样，所以通过hookregisterNatives查找动态注册地址\n确认初始化操作 对上面三个Native层函数进行hook\n可以发现：\n首先调用initializeNative 然后调用initialize,传入字符串main，得到long类型返回值 后面的拦截器都传入了初始化后得到的long类型返回值 上Unidbg unidbg补环境模板\nimport com.github.unidbg.AndroidEmulator; import com.github.unidbg.Emulator; import com.github.unidbg.Module; import com.github.unidbg.arm.backend.Unicorn2Factory; import com.github.unidbg.file.FileResult; import com.github.unidbg.file.IOResolver; import com.github.unidbg.linux.android.AndroidEmulatorBuilder; import com.github.unidbg.linux.android.AndroidResolver; import com.github.unidbg.linux.android.dvm.*; import com.github.unidbg.linux.android.dvm.array.ArrayObject; import com.github.unidbg.memory.Memory; import com.github.unidbg.virtualmodule.android.AndroidModule; import com.github.unidbg.virtualmodule.android.JniGraphics; import com.github.unidbg.virtualmodule.android.MediaNdkModule; import com.github.unidbg.virtualmodule.android.SystemProperties; import java.io.File; import java.util.ArrayList; import java.util.List; public class tmp extends AbstractJni implements IOResolver { private final AndroidEmulator emulator; private final VM vm; private final Module module; public FileResult resolve(Emulator emulator, String pathname, int oflags) { System.out.println(\u0026#34;==================open file=========================\u0026#34;); System.out.println(\u0026#34;open file:\u0026#34; + pathname); return null; } tmp(){ // 创建模拟器实例 emulator = AndroidEmulatorBuilder.for64Bit().setProcessName(\u0026#34;com.xxx\u0026#34;).addBackendFactory(new Unicorn2Factory(false)).build(); // 添加IO接口要加这句 emulator.getSyscallHandler().addIOResolver(this); // 获取模拟器的内存操作接口 final Memory memory = emulator.getMemory(); // 设置系统类库解析 memory.setLibraryResolver(new AndroidResolver(23)); // 创建Android虚拟机,传入APK，Unidbg可以替我们做部分签名校验的工作 vm = emulator.createDalvikVM(new File(\u0026#34;unidbg-android/src/test/java/com//files/.apk\u0026#34;)); // 4个虚拟模块 new AndroidModule(emulator,vm).register(memory); //libandroid.so new MediaNdkModule(emulator,vm).register(memory); // libmediandk.so new JniGraphics(emulator,vm).register(memory); // libjnigraphics.so new SystemProperties(emulator,null).register(memory); // libsystemproperties.so // 设置JNI vm.setJni(this); // 打印日志 vm.setVerbose(true); // 加载目标SO DalvikModule dm = vm.loadLibrary(\u0026#34;soname\u0026#34;, true); // DalvikModule dm = vm.loadLibrary(new File(\u0026#34;unidbg-android/apks/xx/lib.so\u0026#34;), true); //获取本SO模块的句柄,后续需要用它 module = dm.getModule(); // 调用JNI OnLoad dm.callJNI_OnLoad(emulator); }; public void callByAddress(){ // args list List\u0026lt;Object\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); // jnienv list.add(vm.getJNIEnv()); // jclazz list.add(0); // str1 list.add(vm.addLocalObject(new StringObject(vm, \u0026#34;str1\u0026#34;))); // strArr 假设字符串包含两个字符串 // str6_1 StringObject str6_1 = new StringObject(vm, \u0026#34;str6_1\u0026#34;); vm.addLocalObject(str6_1); // str6_2 StringObject str6_2 = new StringObject(vm, \u0026#34;str6_2\u0026#34;); vm.addLocalObject(str6_2); ArrayObject arrayObject = new ArrayObject(str6_1,str6_2); list.add(vm.addLocalObject(arrayObject)); // 最后的int list.add(1); Number number = module.callFunction(emulator, 0x2301, list.toArray()); ArrayObject resultArr = vm.getObject(number.intValue()); System.out.println(\u0026#34;result:\u0026#34;+resultArr); }; public void callByAPI(){ DvmClass RequestCryptUtils = vm.resolveClass(\u0026#34;com/meituan/android/payguard/RequestCryptUtils\u0026#34;); StringObject str6_1 = new StringObject(vm, \u0026#34;str6_1\u0026#34;); vm.addLocalObject(str6_1); StringObject str6_2 = new StringObject(vm, \u0026#34;str6_2\u0026#34;); vm.addLocalObject(str6_2); ArrayObject arrayObject = new ArrayObject(str6_1,str6_2); ArrayObject result = RequestCryptUtils.callStaticJniMethodObject(emulator, \u0026#34;encryptRequestWithRandom()\u0026#34;, \u0026#34;str1\u0026#34;,\u0026#34;str2\u0026#34;, \u0026#34;str3\u0026#34;,\u0026#34;str4\u0026#34;,\u0026#34;str5\u0026#34;,arrayObject,1); System.out.println(result); }; public void trace(){ String traceFile = \u0026#34;unidbg-android/src/test/java/com/xx/trace.txt\u0026#34;; PrintStream traceStream = null; try{ traceStream = new PrintStream(new FileOutputStream(traceFile), true); } catch (FileNotFoundException e) { e.printStackTrace(); } //核心 trace 开启代码，也可以自己指定函数地址和偏移量 emulator.traceCode(module.base,module.base+module.size).setRedirect(traceStream); } public void HookByConsoleDebugger(){ Debugger debugger = emulator.attach(); // debugger.addBreakPoint(module.base + 0x15610); // emulator.traceWrite(0x40420bc0, 0x40420bc0+32); debugger.addBreakPoint(module.findSymbolByName(\u0026#34;memcpy\u0026#34;).getAddress(), new BreakPointCallback() { @Override public boolean onHit(Emulator\u0026lt;?\u0026gt; emulator, long address) { RegisterContext context = emulator.getContext(); int len = context.getIntArg(2); UnidbgPointer pointer1 = context.getPointerArg(0); UnidbgPointer pointer2 = context.getPointerArg(1); Inspector.inspect(pointer2.getByteArray(0,len),\u0026#34;dest \u0026#34;+Long.toHexString(pointer1.peer)+\u0026#34; src \u0026#34;+Long.toHexString(pointer2.peer)); return true; } }); } public static void main(String[] args) { tmp demo = new tmp(); //demo.callByAddress(); //demo.callByAPI(); } } 修改包名，填写apk地址，填写so名称后，开始运行\n补环境 出现第一个环境错误\ncom/xingin/shield/http/ContextHolder-\u0026gt;sLogger:Lcom/xingin/shield/http/ShieldLogger;\n补上\n再次运行，JNI_Onload返回正常。\n第一个初始化 运行报错，补环境\ncase \u0026#34;com/xingin/shield/http/ShieldLogger-\u0026gt;nativeInitializeStart()V\u0026#34;: { return; } 继续补\ncase \u0026#34;java/nio/charset/Charset-\u0026gt;defaultCharset()Ljava/nio/charset/Charset;\u0026#34;:{ return dvmClass.newObject(Charset.defaultCharset()); } 继续补\n通过名称可以看到是在取deviceid，把真机的拿过来就行了\ncase \u0026#34;com/xingin/shield/http/ContextHolder-\u0026gt;sDeviceId:Ljava/lang/String;\u0026#34;: { return new StringObject(vm,\u0026#34;b2e8e75b-d18d-35dc-87c3-490cf0bb7f30\u0026#34;); } 继续补，刚才的appid也拿出来\ncase \u0026#34;com/xingin/shield/http/ContextHolder-\u0026gt;sAppId:I\u0026#34;: { return -319115519; } 继续补\ncase \u0026#34;com/xingin/shield/http/ShieldLogger-\u0026gt;nativeInitializeEnd()V\u0026#34;: { return; } 到此第一个初始化完成\n第二个初始化 继续补环境\ncase \u0026#34;com/xingin/shield/http/ShieldLogger-\u0026gt;initializeStart()V\u0026#34;: { return; } 继续补环境，下面这是经典的补环境问题，建议看龙哥这篇文章SO逆向入门实战教程八：文件读写\n直接给出代码\ncase \u0026#34;android/content/Context-\u0026gt;getSharedPreferences(Ljava/lang/String;I)Landroid/content/SharedPreferences;\u0026#34;: { return vm.resolveClass(\u0026#34;android/content/SharedPreferences\u0026#34;).newObject(vaList.getObjectArg(0).getValue().toString()); } 继续补，跟上面问题是同一个\ncase \u0026#34;android/content/SharedPreferences-\u0026gt;getString(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;\u0026#34;: { String fileName = dvmObject.getValue().toString(); switch (fileName) { case \u0026#34;s\u0026#34;:{ String key = vaList.getObjectArg(0).getValue().toString(); System.out.println(\u0026#34;key:\u0026#34;+key); switch (key) { case \u0026#34;main\u0026#34;:{ return new StringObject(vm,\u0026#34;\u0026#34;); } case \u0026#34;main_hmac\u0026#34;:{ return new StringObject(vm,\u0026#34;u4IlKqm1pHQ/Y6YVkZRNG5+q2KYrjnQUdALX9aN8qWiLP2w8IjCtWoEB35lsCqqOURXQLZ4dPf+HjtuNs/RNUX2KaMHwxCfJN+HTOgUWmdEbbqYn42qyGX/Qw0b19LAo\u0026#34;); } } } } } 继续补\ncase \u0026#34;com/xingin/shield/http/Base64Helper-\u0026gt;decode(Ljava/lang/String;)[B\u0026#34;:{ String input = vaList.getObjectArg(0).getValue().toString(); return new ByteArray(vm, Base64.decodeBase64(input)); } trace 首先trace一份代码，放在一边。\n分析算法 base64 在日志中搜索结果，找到第一次出现的位置\nIDA中跳转过去看看\n别忘记是NewStringUTF函数生成字符串，所以参数a1很有可能是JNIEnv,重命名一下\n看一下这一行的汇编\nx1就应该是第一个参数，下断点看一下\nDebugger debugger = emulator.attach(); debugger.addBreakPoint(module.base + 0xBCF2C); 直接监控谁往地址0x40461018写入，一共134字节\nemulator.traceWrite(0x40461018, 0x40461018+134); 前两个字节 58 59是固定的，所以看后面的写入,到0x9f0f0看看\n上一行是memcpy，下断点看看源数据地址\nDebugger debugger = emulator.attach(); debugger.addBreakPoint(module.base + 0x9F0EC); 追踪地址0x4059a018写入\n跳转到0x4bfac看一下\n点进byte_c0244看一下\n如果熟悉会发现这个base64的ASCII码表\n不熟悉也没事，将整个sub_4BF44函数丢给AI，让AI分析\n现在的关键就是要验证这是不是标准的base64\n在4BF44下断点，看看入参\n对比发现是标准的base64\n那么需要追踪的数据就变成了\n那么继续追踪地址0x40456098的写入\n继续追踪0x40593000的写入\n可以发现，前16个字节是在不同的地址写入的，先看前16字节,0x4972c\nv4来自于第一个入参，看看入参\n是指针，看看这个地址,注意内存中小端序0x404531f0\n那么继续跟踪0x404531f5偏移16字节的写入\n跳转过去可以看到\n前两个00000001都是在so里面固定的\na1是入参第一个，看看入参\nDebugger debugger = emulator.attach(); debugger.addBreakPoint(module.base + 0x4926C); 是一个地址，看看这个地址0x4058e010\n那么根据这个地址的数据以及\nn0x18 = (*(*a1 + 20LL) + *(*a1 + 24LL) + *(*a1 + 28LL) + 24);可以得到\n0x07+0x24+0x10+24 = 0x53\n那么继续看看这0x07+0x24+0x10三个数据是怎么来\nemulator.traceWrite(0x4058e024, 0x4058e024+9); 分别来自\n分别来自a2，a5，n，来自函数4908C的第二个，第五个，第七个参数\n下断点看看参数\nDebugger debugger = emulator.attach(); debugger.addBreakPoint(module.base + 0x4908C); 是个地址，看看0x40459038\n此时就会发现这个数组是传入的appVersionCode\n长度是0x07\n又是一个地址，看看0x4045a018\n是deviceId，长度0x24\n长度0x10，是后面魔改md5的结果\n前16字节到此分析结束，其实通过前面的抓包对比，心里就要有预期，前面可能是固定的\n后面的0x53字节 RC4 追踪地址0x4045e060\nemulator.traceWrite(0x4045e060, 0x4045e060+0x53); 跳转过去看看0x5126c\n代码里面出现许多置换操作和异或操作，很可能是RC4，通过将伪代码丢给AI，也可以分析得到\n那么看看入参\nDebugger debugger = emulator.attach(); debugger.addBreakPoint(module.base + 0x511E0); x1寄存器的0x53不正好是我们数据的长度吗？\n第一个参数就是RC4算法的S盒\n在结果处下断点\n查看入参显示的地址0x4045e060 正好是我们想要的结果\n那么需要验证是否是我们想要的标准RC4算法，那么先找到入参\n我们还知道RC4算法的S盒生成需要密钥，所以我们需要找到这个密钥\n看看是谁调用了函数sub_511E0\n可以看到有两个调用，这个时候使用trace的代码可以轻松的判断只走了第一个\n跳过去看看\n我们知道第一个参数，也就是v21是S盒，那么S盒很有可能在sub_51698中生成\n丢给AI也可以很容易的分析到，这就是RC4的密钥调度算法，用于初始化RC4的S盒。\n那么我们只需要得到这个函数的第三个参数就行了\n其实细心的朋友可以发现，IDA早就帮我们把密钥显示出来了，密钥就是字符std::abort();\n那么验证一下\n验证成功，那么需要追踪的数据就变成了\n可以先分析这段数据的组成\n00 00 00 01 + app_id + 00 00 00 02 00 00 00 07 00 00 00 24 00 00 00 10 + build + deviceId + 18 D2 64 FD 56 08 DB 27 20 90 1F F0 65 A4 BF 27\n看看unidbg日志中有没有这段数据的记录\n其中00 00 00 01固定，00 00 00 02 00 00 00 07 00 00 00 24 00 00 00 10是之前分析前16字节的数据\n那么只剩下最后的16字节未知，16字节的数据，那么很有可能与哈希算法中的md5有关。\n魔改HMAC MD5 在unidbg控制台搜索一下\n追踪一下地址0xbffff478,16个字节\nemulator.traceWrite(0xbffff478L, 0xbffff478+16); 跳转过去看一下0x546d8\n跳转过去正在赋值\na1来自a2，a2被传入了函数sub_539DC，点进去看看，发现大量的移位，异或等操作，这就是加密的地方\n在trace的日志中发现这个函数执行了五次\n看看入参\n第一次进入sub_539DC\n第一个参数很像md5的初始化常量，但是顺序被魔改了\n正常的初始化常量\nA=0x67452301 B=0xefcdab89 C=0x98badcfe D=0x10325476 这里传入的初始化常量\nA=0X10325476 B=0X98BADCFE C=0XEFCDAB89 D=0X67452301 第二个参数中出现了大量的0x36\n返回值\n第二次进入sub_539DC\n同样的初始化常量\n5C也是HMAC的特征\n返回值\n第三次进入sub_539DC\n传入的第一个参数用到了第一次md5的结果，第二个参数是要加密的字符串\n返回值 第四次进入sub_539DC\n第一个参数是第三次的MD5结果，第二个参数明显可以看到填充特征0x80，以及最后八个字节消息长度，注意是小端序，那么长度为0x30e8。\n返回值\n第五次进入sub_539DC\n第一个参数是第二次的返回值，第二个参数是第四次的返回值以及填充\n返回值\n返回值正是我们要找的数据。\n分析一下加密流程\n第一次将HMAC的密钥与0x36异或生成扩展密钥1，由于恰好扩展密钥1长度为64字节，恰好为一个分组，那么可以先计算出第一次md5结果，称为md5-1 第二次将HMAC的密钥与0x36异或生成扩展密钥2，由于恰好扩展密钥2长度为64字节，恰好为一个分组，那么可以先计算出第一次md5结果，称为md5-2 第三次，回到之前我的文章中介绍，第一次hash的输入是扩展密钥1 + 输入字符串,并且md5分组加密，第二组的初始化常量为第一组的md5结果。如此一来，恰好对应第三次的初始化常量为第一次的md5结果。 第四次，初始化常量为第三次计算的md5结果，输入为剩余未加密的数据，当函数运行完，至此HMAC的第一次hash完结 第五次正是HMAC的第二次hash，第二次hash的输入是扩展密钥2+第一次哈希，由于扩展密钥2长度为64字节，恰好为一个分组，那么第一个参数初始化常量不正好是第二次的md5结果吗，再加上第二个参数输入为第一次哈希并且填充。最终得到我们想要的结果。 那么到现在先确定初始化常量是被魔改了的，找来一份标准的md5，将初始化常量修改，并且传进入参，看看是不是这样 入参\n会发现结果不对，说明魔改点不仅仅是初始化常量，分析ida的伪代码。\n仔细分析可以发现，在标准算法中的循环左移变成了循环右移，这不是关键，可能是伪代码的识别问题，但是这里第一个循环右移位数是26，等价于循环左移6位。但在标准的md5算法中，第一个循环左移位数是7。那么循环左移的位数发生了变化，照着伪代码修改循环左移的位数。\n会发现修改了循环左移位数还是不行，那么考虑经常遇到的魔改K表\n那么通过分析64轮中第一轮的计算情况\n从a = (a + F(b, c, d) + x + ac) \u0026amp; 0xFFFFFFFF来着手分析\n其中((v3 ^ v4) \u0026amp; v5 ^ v4)对应着F函数，v6对应着a，v7来自入参a2，对应着标准代码中的words[0]，那么result[23]就是代表从K表中取值了。搜索伪代码发现存在result[86],刚好对应从0-63即64个K值表\nK表可以从trace从一个个找，也可以从unidbg中直接打印出来\n我选择从unidbg中打印出来\n鼠标放在result上，按下TAB，查看这一行的汇编\nldp: Load Pair，表示加载一对寄存器值 w27, w30: 目标寄存器，表示将数据加载到 32 位寄存器 w27 和 w30 中（w 表示 32 位，相对于 64 位的 x 寄存器）。 那么在0X53D5C处下断，x0里就是我们的K表了\n第一行是不是很熟悉，说明传入的第一个参数里面除了包含初始化常量，还包含了K表\n将K表拿下来，替换标准md5，照着伪代码改，注意在第二大轮中的第一轮，第四轮，第十四轮K值还分别与0xFF00FF00,FF0011FF,0xFF110011\n然而，改完之后，发现MD5的结果还是不对。\n那么尝试在四大轮，每一轮结束后打印A,B,C,D的值，然后再trace中搜索\n搜索发现第一，第二大轮的结果能搜索到，第三大轮开始就搜索不到，那么问题就出现在这之间了，继续缩小范围\n缩小到第40轮时，发现B值无法在trace中搜索到\n通过对上面正确的轮加密进行变量重命名 v102的值应该是A，重复此操作，会发现40轮与41轮发生了交换，42与43轮发生了交换\n其实使用上面修改完的MD5实现还原时，会发现前面两次函数进入的结果都对，第三次传入的字符串不对，最终发现填充也发生了魔改，最后的消息长度会加上一个分组的长度。\n到此md5还原成功。\n还剩下HMAC的key不知道是怎么来的\nAES 现在就变成了寻找这一段数据\n在unidbg中看看日志\ntrace这一段内存的写入\nemulator.traceWrite(0x4045e010, 0x4045e010+64); 跳转过去看看汇编\n看不懂思密达，问一下AI\n那么Q0的值就是来自于Q0与Q1的异或，在trace文件中可以看到这一地址执行了6次，可惜在trace的文件中无法看到Q系列寄存器，没事，下断点看\nDebugger debugger = emulator.attach(); debugger.addBreakPoint(module.base + 0x52A68); 在python中打印结果\n正是我们需要的结果，不过是反着来的\n那么我们就需要找到前面异或的数据是怎么来的\n别忘了前面传入的数据还没用到从SharedPreferences读取到的main-hmac\n正是输入的右边部分\n在这里a6正是加密函数\n可是跳转不过去\n在trace中找到这一行的地址，跳转过去\n看一下输入\nx0是不是很熟悉\nx1看不出来什么\nx2 的大小16 * 11 = 176字节，这不正好是AES扩展后的11个密钥吗？\n不建议照着标准AES改，后面的魔改AES就得照着IDA跟trace扣代码了，最后剩下体力活\n",
    
    "date": "2025-04-25 17:48:36",
    "updated": "2025-04-25 17:48:36"
  }
  
  , 
  {
    "objectID": "1745572896",
    "permalink": "/post/rc4/",
    "title": "RC4原理及代码实现",
    
    "content": "在密码学中，RC4（Rivest Cipher 4，也称为 ARC4 或 ARCFOUR， 意思是Alleged（所谓的） RC4）是一种流密码 。虽然它在软件中以其简单性和速度而著称，但在 RC4 中发现了多个漏洞，使其不安全。 流密码（streamcipher）是对数据流进行连续处理的一类密码算法。流密码中一般以1比特、8比特或32比特等为单位进行加密和解密。其中RC4的加解密单位为8比特，也就是一个字节。\n1. 密码学中为什么经常使用异或？ 在密码学中经常使用异或运算，RC4的原理也依赖异或运算。 下面解释摘自《图解密码技术 第三版》\n由于两个相同的数进行XOR运算的结果一定为0，因此如果将A⊕B的结果再与B进行XOR运算，则结果会变回A。也就是说，两个公式中的B会相互抵消。\n将明文A用密钥B进行加密，得到密文A⊕B 将密文A⊕B用密钥B进行解密，得到明文A 图片摘自《图解密码技术 第三版》 从图中可以看出，执行一次蒙版操作后，原来的图像被隐藏（掩盖）了，而执行两次蒙版操作后，就又可以得到原来的图像了。 如果所使用的蒙版是完全随机的比特序列，则使用XOR就可以将原来的图像掩盖起来。但如果蒙版中的比特序列的排列是可以被推测出来的，那么实质上图像就没有被真正掩盖。对于密码技术来说，“是否可以预测”是非常重要的一点。能够产生不可预测的比特序列，对于密码技术的贡献是巨大的。这种不可预测的比特序列就称为随机数。\n2. 算法实现过程 2.1. KSA(key-scheduling algorithm) 使用密钥调度算法(key-scheduling algorithm)\n输入：一个可变长度的密钥（通常8-2048位）。 输出：一个256字节的置换数组S（S[0]到S[255]）。 2.1.1. 第一步 先初始化256字节的数组S，填充0到255的整数，即S[0]=0, S[1]=1, \u0026hellip;, S[255]=255。\n2.1.2. 第二步 创建一个临时数组T，长度与密钥相同，将密钥循环填充到T中（如果密钥长度不足256字节，则重复密钥）。\n2.1.3. 第三步 使用以下伪代码进行置换\nfor i = 0 to 255 j = (j + S[i] + T[i]) mod 256 swap S[i] and S[j] S数组被打乱，形成一个基于密钥的伪随机置换表。这样处理之后，就得到了介绍中提到的不可预测的比特序列\n2.2. PRGA(pseudo-random generation algorithm) 使用伪随机生成算法生成比特流。\n输入：初始化后的S数组，待加密/解密的明文/密文。 输出：与明文/密文等长的密钥流（keystream）。 初始化两个变量i和j为0，执行以下伪代码 i = (i + 1) mod 256 j = (j + S[i]) mod 256 swap S[i] and S[j] t = (S[i] + S[j]) mod 256 output S[t] 生成与输入明文/密文等长的密钥流。\n3. 密文与明文关系 根据前面的介绍可以得到如下关系\n将生成的密钥流与明文逐字节进行异或(XOR)操作，得到密文： 密文[i] = 明文[i] XOR 密钥流[i] 解密过程相同，因为XOR是可逆的： 明文[i] = 密文[i] XOR 密钥流[i] 4. 代码实现 Python\n#!/usr/bin/env python # -*- coding: utf-8 -*- # author: @manojpandey # Python 3 implementation for RC4 algorithm # Brief: https://en.wikipedia.org/wiki/RC4 # Will use codecs, as \u0026#39;str\u0026#39; object in Python 3 doesn\u0026#39;t have any attribute \u0026#39;decode\u0026#39; import codecs MOD = 256 def KSA(key): \u0026#39;\u0026#39;\u0026#39; Key Scheduling Algorithm (from wikipedia): for i from 0 to 255 S[i] := i endfor j := 0 for i from 0 to 255 j := (j + S[i] + key[i mod keylength]) mod 256 swap values of S[i] and S[j] endfor \u0026#39;\u0026#39;\u0026#39; key_length = len(key) # create the array \u0026#34;S\u0026#34; S = list(range(MOD)) # [0,1,2, ... , 255] j = 0 for i in range(MOD): j = (j + S[i] + key[i % key_length]) % MOD S[i], S[j] = S[j], S[i] # swap values return S def PRGA(S): \u0026#39;\u0026#39;\u0026#39; Psudo Random Generation Algorithm (from wikipedia): i := 0 j := 0 while GeneratingOutput: i := (i + 1) mod 256 j := (j + S[i]) mod 256 swap values of S[i] and S[j] K := S[(S[i] + S[j]) mod 256] output K endwhile \u0026#39;\u0026#39;\u0026#39; i = 0 j = 0 while True: i = (i + 1) % MOD j = (j + S[i]) % MOD S[i], S[j] = S[j], S[i] # swap values K = S[(S[i] + S[j]) % MOD] yield K def get_keystream(key): \u0026#39;\u0026#39;\u0026#39; Takes the encryption key to get the keystream using PRGA return object is a generator \u0026#39;\u0026#39;\u0026#39; S = KSA(key) return PRGA(S) def encrypt_logic(key, text): \u0026#39;\u0026#39;\u0026#39; :key -\u0026gt; encryption key used for encrypting, as hex string :text -\u0026gt; array of unicode values/ byte string to encrpyt/decrypt \u0026#39;\u0026#39;\u0026#39; # For plaintext key, use this key = [ord(c) for c in key] # If key is in hex: # key = codecs.decode(key, \u0026#39;hex_codec\u0026#39;) # key = [c for c in key] keystream = get_keystream(key) res = [] for c in text: val = (\u0026#34;%02X\u0026#34; % (c ^ next(keystream))) # XOR and taking hex res.append(val) return \u0026#39;\u0026#39;.join(res) def encrypt(key, plaintext): \u0026#39;\u0026#39;\u0026#39; :key -\u0026gt; encryption key used for encrypting, as hex string :plaintext -\u0026gt; plaintext string to encrpyt \u0026#39;\u0026#39;\u0026#39; plaintext = [ord(c) for c in plaintext] return encrypt_logic(key, plaintext) def decrypt(key, ciphertext): \u0026#39;\u0026#39;\u0026#39; :key -\u0026gt; encryption key used for encrypting, as hex string :ciphertext -\u0026gt; hex encoded ciphered text using RC4 \u0026#39;\u0026#39;\u0026#39; ciphertext = codecs.decode(ciphertext, \u0026#39;hex_codec\u0026#39;) res = encrypt_logic(key, ciphertext) return codecs.decode(res, \u0026#39;hex_codec\u0026#39;).decode(\u0026#39;utf-8\u0026#39;) def main(): key = \u0026#39;not-so-random-key\u0026#39; # plaintext plaintext = \u0026#39;Good work! Your implementation is correct\u0026#39; # plaintext # encrypt the plaintext, using key and RC4 algorithm ciphertext = encrypt(key, plaintext) print(\u0026#39;plaintext:\u0026#39;, plaintext) print(\u0026#39;ciphertext:\u0026#39;, ciphertext) # .. # Let\u0026#39;s check the implementation # .. ciphertext = \u0026#39;2D7FEE79FFCE80B7DDB7BDA5A7F878CE298615\u0026#39;\\ \u0026#39;476F86F3B890FD4746BE2D8F741395F884B4A35CE979\u0026#39; # change ciphertext to string again decrypted = decrypt(key, ciphertext) print(\u0026#39;decrypted:\u0026#39;, decrypted) if plaintext == decrypted: print(\u0026#39;\\nCongrats ! You made it.\u0026#39;) else: print(\u0026#39;Shit! You pooped your pants ! .-.\u0026#39;) # until next time folks ! def test(): # Test case 1 # key = \u0026#39;4B6579\u0026#39; # \u0026#39;Key\u0026#39; in hex # key = \u0026#39;Key\u0026#39; # plaintext = \u0026#39;Plaintext\u0026#39; # ciphertext = \u0026#39;BBF316E8D940AF0AD3\u0026#39; assert(encrypt(\u0026#39;Key\u0026#39;, \u0026#39;Plaintext\u0026#39;)) == \u0026#39;BBF316E8D940AF0AD3\u0026#39; assert(decrypt(\u0026#39;Key\u0026#39;, \u0026#39;BBF316E8D940AF0AD3\u0026#39;)) == \u0026#39;Plaintext\u0026#39; # Test case 2 # key = \u0026#39;Wiki\u0026#39; # \u0026#39;57696b69\u0026#39;in hex # plaintext = \u0026#39;pedia\u0026#39; # ciphertext should be 1021BF0420 assert(encrypt(\u0026#39;Wiki\u0026#39;, \u0026#39;pedia\u0026#39;)) == \u0026#39;1021BF0420\u0026#39; assert(decrypt(\u0026#39;Wiki\u0026#39;, \u0026#39;1021BF0420\u0026#39;)) == \u0026#39;pedia\u0026#39; # Test case 3 # key = \u0026#39;Secret\u0026#39; # \u0026#39;536563726574\u0026#39; in hex # plaintext = \u0026#39;Attack at dawn\u0026#39; # ciphertext should be 45A01F645FC35B383552544B9BF5 assert(encrypt(\u0026#39;Secret\u0026#39;, \u0026#39;Attack at dawn\u0026#39;)) == \u0026#39;45A01F645FC35B383552544B9BF5\u0026#39; assert(decrypt(\u0026#39;Secret\u0026#39;, \u0026#39;45A01F645FC35B383552544B9BF5\u0026#39;)) == \u0026#39;Attack at dawn\u0026#39; if __name__ == \u0026#39;__main__\u0026#39;: main() ",
    
    "date": "2025-04-25 17:21:36",
    "updated": "2025-04-25 17:21:36"
  }
  
  , 
  {
    "objectID": "1745500236",
    "permalink": "/post/wb_aes/",
    "title": "AES原理及白盒AES的DFA攻击",
    
    "content": "AES（Advanced Encryption Standard） 高级加密标准是 Rijndael 分组密码 的一种变体，由两位密码学家 Joan Daemen 和 Vincent Rijmen 开发，他们在 AES 选择过程中向 NIST 提交了一份提案Rijndael 是一系列具有不同密钥和块大小的密码。对于 AES，NIST 选择了 Rijndael 家族的三个成员，每个成员的块大小为 128 位，但有三种不同的密钥长度：128、192 和 256 位。\n1. AES分类 分类 密钥长度 轮密钥长度 扩展密钥长度 分组长度 加密轮数 AES-128 16字节 16字节 16*11=172 16字节 10 AES-192 24字节 16字节 16*13=208 16字节 12 AES-256 32字节 16字节 16*15=240 16字节 14 AES 128 192 256 除了密钥编排算法不一样和加密轮数不一样 其余的计算逻辑相同\nAES 128 192 256 CBC 模式IV的长度都是16个字节 CBC计算逻辑相同\nAES-128 密钥编排中K0是原始密钥 共16个字节\nAES-192 密钥编排中K0和K1前半部分是原始密钥 共24个字节\nAES-256 密钥编排中K0和K1是原始密钥 共32个字节\n如非特别说明，下面加密介绍中AES都以AES-128为例\n2. PKCS填充方式 PKCS5填充字符串由一个1~8位的字节序列组成，每个字节填充该字节序列的长度 PKCS7（95% 都是PKCS7）填充字符串由一个1-255位的字节序列组成，每个字节填充该字节序列的长度 比如 AES-128的数据块长度是 16bytes，使用PKCS7进行填充时，填充的长度范围是 1 ~ 16\n示例一： 数据： FF FF FF FF FF FF FF FF FF\nPKCS5 填充： FF FF FF FF FF FF FF FF FF 07 07 07 07 07 07 07 PKCS7 填充： FF FF FF FF FF FF FF FF FF 07 07 07 07 07 07 07 示例二：\n数据： FF FF FF FF FF FF FF FF FF FF\nPKCS5 填充： FF FF FF FF FF FF FF FF FF FF 06 06 06 06 …",
    
    "date": "2025-04-24 21:10:36",
    "updated": "2025-04-24 21:10:36"
  }
  
  , 
  {
    "objectID": "1745466336",
    "permalink": "/post/mhac/",
    "title": "HMAC原理及代码实现",
    
    "content": "HMAC（Hash-based Message Authentication Code，散列消息认证码）是一种使用密码散列函数，同时结合一个加密密钥，通过特别计算方式之后产生的消息认证码（MAC）。 HMAC算法利用哈希运算，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。 hmac算法通常需要以一个hash函数为载体,比如常见的有hmacMd5,hmacSha1,hmacSha256,目前在so里只见到过hmacMd5,hmacSha256,但是hmac的规则是适用所有hash函数的\nHMAC算法的数学公式为： 其中：\nH 为密码Hash函数（如MD5或SHA-2)，能够对明文进行分组循环压缩；\nK 为密钥（secret key）；\nm 为要认证的消息；\nK’ 是从原始密钥 k 导出的另一个密钥（如果 k 短于散列函数的输入块大小，则向右填充零；如果比该块大小更长，则对 k 进行散列）；\nipad 内部填充（0x5C5C5C…5C5C，一段十六进制常量）；\nopad 外部填充（0x363636…3636，一段十六进制常量)；\n⊕：按位异或运算。\n||：字符串拼接。\n总结8个字就是:两次加盐,两次hash。\n1. 算法实现过程 HMAC需要选择一个哈希函数作为实现的载体，这里以MD5为例\n1.1. 第一步：扩展密钥 以字符串admin为例，十六进制如下\n61 64 6D 69 6E 填充密钥到64字节\n61 64 6D 69 6E 00(填充59次) 1.2. 异或0x36 将密钥逐字节异或0x36，得到扩展密钥1，0x36十进制是54\n57 52 5b 5f 58 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 1.3. 异或0x5C 将密钥逐字节异或0x5c，得到扩展密钥2，0x5C十进制是92\n3d 38 31 35 32 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 1.4. 计算，两次加盐，两次哈希 1.4.1. 第一次加盐 扩展密钥1+输入,假设输入是hello,68 65 6c 6c 6f\n57 52 5b 5f 58 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 68 65 6c 6c 6f 1.4.2. 第一次哈希 上面提到，我们选择了MD5作为载体，那么对上面的数据进行一次MD5计算\n5511e8d27f4692a69a4f6cfebbac574b 1.4.3. 第二次加盐 扩展密钥2+第一次哈希的结果\n3d 38 31 35 32 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 55 11 e8 d2 7f 46 92 a6 9a 4f 6c fe bb ac 57 4b 1.4.4. 第二次哈希 对上面的输入进行一次MD5计算\n83e029bbdf98117cafe2b973ab8a4a0f 验证成功\n2. 代码实现 Python\nimport hashlib import hmac key1 = \u0026#39;57525b5f583636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636\u0026#39; key2 = \u0026#39;3d383135325c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c\u0026#39; inputStr = \u0026#39;hello\u0026#39; str1 = bytes.fromhex(key1) + inputStr.encode() # 第一次加盐 sign1 = hashlib.md5(str1).hexdigest() # 第一次hash print(\u0026#39;sign1\u0026#39;,sign1) str2 = bytes.fromhex(key2) + bytes.fromhex(sign1) # 第二次加盐 sign2 = hashlib.md5(str2).hexdigest() # # 第二次hash print(\u0026#39;sign2\u0026#39;,sign2) sign = hmac.new(\u0026#39;admin\u0026#39;.encode(), \u0026#39;hello\u0026#39;.encode(), hashlib.md5).hexdigest() print(\u0026#39;sign\u0026#39;,sign) ",
    
    "date": "2025-04-24 11:45:36",
    "updated": "2025-04-24 11:45:36"
  }
  
  , 
  {
    "objectID": "1745413836",
    "permalink": "/post/sha-512/",
    "title": "SHA-512简介及代码实现",
    
    "content": " 1. 算法 SHA-512在app逆向中遇到得很少，所以只作简单介绍 SHA-1可以生成一个被称为消息摘要的512位（64字节）散列值，散列值通常的呈现形式为128个十六进制数。与MD5，SHA1，SHA256不同的是，分组长度为1024位。表示消息长度为128位\n2. 算法实现过程 2.1. 填充 以字符串admin为例，十六进制如下\n61 64 6D 69 6E 首先需要填充到128字节，即先添加一个“1”，再后跟多个“0”，然后再追加一个128位的消息长度信息 第一位填充 0x80 剩下的填充 0 直到达到 112 个字节 填充K个“0”，所不同的是消息分组的长度是1024位，所以K的取值必须是满足下述表达式的最小非负整数值。 ( L + 1 + K ) mod 1024 = 896\n61 64 6D 69 6E 80 0(填充106次) 共 112 个字节 对比md5,sha1,sha256填充都是64字节分组,sha512是128字节分组,原因就在于无论是iv还是k都是8字节的,所以数据块也是8字节的\nsha512 H = [ 0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1, 0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179 ] sha256 H = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 ] sha512的高4字节是sha256的4字节,同理k表也是这样\n",
    
    "date": "2025-04-23 21:10:36",
    "updated": "2025-04-23 21:10:36"
  }
  
  , 
  {
    "objectID": "1745399690",
    "permalink": "/post/sha-256/",
    "title": "SHA-256原理及代码实现",
    
    "content": "SHA256是SHA-2下细分出的一种算法 SHA-2，名称来自于安全散列算法2（英语：Secure Hash Algorithm 2）的缩写，一种密码散列函数算法标准，由美国国家安全局研发，属于SHA算法之一，是SHA-1的后继者。 SHA-2下又可再分为六个不同的算法标准 包括了：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。 SHA-1可以生成一个被称为消息摘要的256位（32字节）散列值，散列值通常的呈现形式为64个十六进制数。\n1. 算法实现过程 1.1. 第一步：填充 以字符串admin为例，十六进制如下\n61 64 6D 69 6E 首先需要填充到64字节 第一位填充 0x80 剩下的填充 0 直到达到 56 个字节\n61 64 6D 69 6E 80 0(填充50次) 共 56 个字节 接下来 8 个字节 第一位填充消息长度 * 8，也就是5 * 8 = 40 = 0x28\n61 64 6D 69 6E 80 0(填充50次) 0(填充7次) 0x28 共 64 个字节 sha-256和sha-1的填充一样,对比md5,sha-1,sha-256,填充几乎都一样,唯一不同之处就是md5的附加消息长度是小端序,其余两个是大端序。\n1.2. 第二步：扩充 需要将16个四字节扩充至64个四字节 前16个四字节复制填充后的16个四字节 后48个四字节使用扩充算法进行扩充 sha256 for i in range(16, 64): s0 = right_rotate(W[i-15], 7) ^ right_rotate(W[i-15], 18) ^ (W[i-15] \u0026amp;gt;\u0026amp;gt; 3) s1 = right_rotate(W[i-2], 17) ^ right_rotate(W[i-2], 19) ^ (W[i-2] \u0026amp;gt;\u0026amp;gt; 10) W[i] = (W[i-16] + s0 + W[i-7] + s1) \u0026amp;amp; 0xffffffff sha1 for j in range(16, 80): w[j] = left_rotate(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1) 和sha-1的区别在于sha-1扩展64 …",
    
    "date": "2025-04-23 17:14:50",
    "updated": "2025-04-23 17:14:50"
  }
  
  , 
  {
    "objectID": "1745386116",
    "permalink": "/post/sha-1/",
    "title": "SHA-1原理及代码实现",
    
    "content": "SHA-1（英語：Secure Hash Algorithm 1，中文名：安全散列算法1）是一种密码散列函数，美国国家安全局设计。SHA-1可以生成一个被称为消息摘要的160位（20字节）散列值，散列值通常的呈现形式为40个十六进制数。\n1. 算法实现过程 1.1. 第一步：填充 以字符串admin为例，十六进制如下\n61 64 6D 69 6E 需要让它填充到64个字节长度\n第一位填充 0x80 剩下的填充 0 直到达到 56 个字节\n61 64 6D 69 6E 80 0(填充50次) 共 56 个字节 接下来 8 个字节 消息长度 * 8，也就是5 * 8 = 40 = 0x28\n61 64 6D 69 6E 80 0(填充50次) 0(填充7次) 0x28 共 64 个字节 填充这块唯一和md5有区别的就是,最后的附加消息长度是大端续,也就是正常的顺序 64字节的分组长度,md5,sha1,sha256都是, sha512是128字节分组。\n1.2. 第二步：扩充 sha1有80轮循环,每一轮要用不同的数据,而填充后的最多只有16个4字节数据,所以需要进行扩展\n前16个四字节复制填充后的16个四字节 后64个四字节使用扩充算法进行扩充 当前位置值 =（ 前面第3个四字节 ^ 前面第8个四字节 ^ 前面第14个四字节 ^ 前面第16个四字节 ）\u0026amp;laquo; 1\n\u0026amp;laquo; 代表循环左移 用代码表示\n# 扩展到80个字 for j in range(16, 80): w[j] = left_rotate(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1) 以字符串admin为例，扩充如下\n0x61646D69 0x6E800000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000028 0xC2C8DAD2 0xDD000000 0x00000050 0x8591B5A5 0xBA000001 0x000000A0 0x0B236B4B 0x74000053 …",
    
    "date": "2025-04-23 13:28:36",
    "updated": "2025-04-23 13:28:36"
  }
  
  , 
  {
    "objectID": "1745380130",
    "permalink": "/post/md5/",
    "title": "MD5原理及代码实现",
    
    "content": "MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16个字节）的散列值（hash value），用于确保资讯传输完整一致。 将数据（如一段文字）运算变为另一固定长度值，是散列算法的基础原理。\n1. 算法 MD5是输入不定长度，输出固定长度128-bits的算法。经过程序流程，生成四个32位数据，最后联合起来成为一个128-bits（16字节，通常消息传输中更常见表示为32 个十六进制字符）散列。\n2. 算法实现过程 2.1. 第一步：填充 MD5 的输入数据需要满足以下条件：\n数据长度（以位为单位）模 512 等于 448（即模 64 字节等于 56 字节）。 填充后，数据长度必须是 512 位的倍数（即 64 字节的倍数）。 以字符串admin为例，十六进制如下\n61 64 6D 69 6E 首先需要填充到64字节 第一位填充 0x80 剩下的填充 0 直到达到 56 个字节\n61 64 6D 69 6E 80 0(填充50次) 共 56 个字节 接下来 8 个字节 第一位填充消息长度 * 8，也就是5 * 8 = 40 = 0x28，（0x28 \u0026amp;amp; 0xFF）剩下的填充0\n61 64 6D 69 6E 80 0(填充50次) 0x28 0(填充7次) 共 64 个字节 2.1.1. 当输入大小恰好为56字节时 理论上，只需添加 0x80 和长度信息即可，但由于 0x80 占用 1 字节，剩余空间不足以容纳 8 字节的长度信息，因此需要填充到下一个 512 位块。\n在数据末尾添加 0x80（二进制 10000000），占用 1 字节。 当前长度：56 字节 + 1 字节 = 57 字节（456 位）。 因此，填充到下一个 512 位块（128 字节 = 1024 位）\n目标长度（不含长度信息）：128 字节 - 8 字节 = 120 字节。 当前长度：57 字节。 需要填充：120 字节 - 57 字节 = 63 字节。 填充 63 个 0x00 字节。 再在尾部加上消息长度信息，原始数据长度：56 × 8 = 448 位。用 64 位表示：0x000001C0（低位在前），填充为 8 字节：0xC0010000 00000000。 那么当输入大小大于56字节且小 …",
    
    "date": "2025-04-23 11:48:50",
    "updated": "2025-04-23 11:48:50"
  }
  
  , 
  {
    "objectID": "1654776772",
    "permalink": "/post/main/",
    "title": "Markdown Basic Elements",
    
    "content": " Markdown 基本元素 标题 H1 H2 H3 H4 H5 H6 强调 Emphasis, aka italics, with asterisks or underscores.\nStrong emphasis, aka bold, with asterisks or underscores.\nCombined emphasis with asterisks and underscores.\nStrikethrough uses two tildes. Scratch this.\n列表 Definition List (dl) Ordered List (ol) List Item 1 List Item 2 List Item 3 Unordered List (ul) List Item 1 List Item 2 List Item 3 段落 Lorem ipsum dolor sit amet, test link consectetur adipiscing elit. Strong text pellentesque ligula commodo viverra vehicula. Italic text at ullamcorper enim. Morbi a euismod nibh. Underline text non elit nisl. Deleted text tristique, sem id condimentum tempus, metus lectus venenatis mauris, sit amet semper lorem felis a eros. Fusce egestas nibh at sagittis auctor. Sed ultricies ac arcu quis molestie. Donec dapibus nunc in nibh egestas, vitae volutpat sem iaculis. Curabitur sem tellus, elementum nec quam id, fermentum laoreet mi. Ut mollis ullamcorper turpis, vitae facilisis velit ultricies sit amet. Etiam …",
    
    "date": "2022-06-09 20:12:52",
    "updated": "2022-06-09 20:12:52"
  }
  
]