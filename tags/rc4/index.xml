<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>RC4 on My New Hugo Site</title>
    <link>https://example.org/tags/rc4/</link>
    <description>Recent content from My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en</language>
    
    <managingEditor>unknow (Asu1tty)</managingEditor>
    <webMaster>unknow (Asu1tty)</webMaster>
    
    <copyright>All articles on this blog are licensed under the BY-NC-SA license agreement unless otherwise stated. Please indicate the source when reprinting!</copyright>
    
    <lastBuildDate>Fri, 25 Apr 2025 17:21:36 +0800</lastBuildDate>
    
    
    <atom:link href="https://example.org/tags/rc4/index.xml" rel="self" type="application/rss&#43;xml" />
    

    
    

    <item>
      <title>RC4原理及代码实现</title>
      <link>https://example.org/post/rc4/</link>
      <pubDate>Fri, 25 Apr 2025 17:21:36 &#43;0800</pubDate>
      <author>unknow (Asu1tty)</author>
      <guid>https://example.org/post/rc4/</guid>
      <description>
        <![CDATA[<h1>RC4原理及代码实现</h1><p>Author: Asu1tty(unknow)</p>
        
          <p>在<a href="https://en.wikipedia.org/wiki/Cryptography" title="Cryptography">密码学</a>中，<strong>RC4</strong>（Rivest Cipher 4，也称为 <strong>ARC4</strong> 或 <strong>ARCFOUR，</strong> 意思是Alleged（所谓的） RC4）是一种<a href="https://en.wikipedia.org/wiki/Stream_cipher" title="Stream cipher">流密码</a> 。虽然它在软件中以其简单性和速度而著称，但在 RC4 中发现了多个漏洞，使其不安全。
流密码（streamcipher）是对数据流进行连续处理的一类密码算法。流密码中一般以1比特、8比特或32比特等为单位进行加密和解密。其中RC4的加解密单位为8比特，也就是一个字节。</p>
<h2 id="1-密码学中为什么经常使用异或">
<a class="header-anchor" href="#1-%e5%af%86%e7%a0%81%e5%ad%a6%e4%b8%ad%e4%b8%ba%e4%bb%80%e4%b9%88%e7%bb%8f%e5%b8%b8%e4%bd%bf%e7%94%a8%e5%bc%82%e6%88%96"></a>
1. 密码学中为什么经常使用异或？
</h2><p>在密码学中经常使用异或运算，<code>RC4</code>的原理也依赖异或运算。
下面解释摘自《图解密码技术 第三版》</p>
<p><code>由于两个相同的数进行XOR运算的结果一定为0，因此如果将A⊕B的结果再与B进行XOR运算，则结果会变回A。也就是说，两个公式中的B会相互抵消。</code></p>
<ul>
<li>将明文A用密钥B进行加密，得到密文A⊕B</li>
<li>将密文A⊕B用密钥B进行解密，得到明文A
<img src="https://cdn.jsdelivr.net/gh/Asu1tty/blog_img@master/picSource/image-20250425172319106.png" alt="image-20250425172319106">
图片摘自《图解密码技术 第三版》</li>
</ul>
<p><code>从图中可以看出，执行一次蒙版操作后，原来的图像被隐藏（掩盖）了，而执行两次蒙版操作后，就又可以得到原来的图像了。</code>
<code>如果所使用的蒙版是完全随机的比特序列，则使用XOR就可以将原来的图像掩盖起来。但如果蒙版中的比特序列的排列是可以被推测出来的，那么实质上图像就没有被真正掩盖。对于密码技术来说，“是否可以预测”是非常重要的一点。能够产生不可预测的比特序列，对于密码技术的贡献是巨大的。这种不可预测的比特序列就称为随机数。</code></p>
<h2 id="2-算法实现过程">
<a class="header-anchor" href="#2-%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0%e8%bf%87%e7%a8%8b"></a>
2. 算法实现过程
</h2><h3 id="21-ksakey-scheduling-algorithm">
<a class="header-anchor" href="#21-ksakey-scheduling-algorithm"></a>
2.1. KSA(key-scheduling algorithm)
</h3><p>使用密钥调度算法(key-scheduling algorithm)</p>
<ul>
<li><strong>输入</strong>：一个可变长度的密钥（通常8-2048位）。</li>
<li><strong>输出</strong>：一个256字节的置换数组S（S[0]到S[255]）。</li>
</ul>
<h4 id="211-第一步">
<a class="header-anchor" href="#211-%e7%ac%ac%e4%b8%80%e6%ad%a5"></a>
2.1.1. 第一步
</h4><p>先初始化256字节的数组S，填充0到255的整数，即S[0]=0, S[1]=1, &hellip;, S[255]=255。</p>
<h4 id="212-第二步">
<a class="header-anchor" href="#212-%e7%ac%ac%e4%ba%8c%e6%ad%a5"></a>
2.1.2. 第二步
</h4><p>创建一个临时数组T，长度与密钥相同，将密钥循环填充到T中（如果密钥长度不足256字节，则重复密钥）。</p>
<h4 id="213-第三步">
<a class="header-anchor" href="#213-%e7%ac%ac%e4%b8%89%e6%ad%a5"></a>
2.1.3. 第三步
</h4><p>使用以下伪代码进行置换</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for i = 0 to 255
</span></span><span class="line"><span class="cl">    j = (j + S[i] + T[i]) mod 256
</span></span><span class="line"><span class="cl">    swap S[i] and S[j]
</span></span></code></pre></div><p>S数组被打乱，形成一个基于密钥的伪随机置换表。这样处理之后，就得到了介绍中提到的<code>不可预测的比特序列</code></p>
        
        <hr><p>Published on 2025-04-25 at <a href='https://example.org/'>My New Hugo Site</a>, last modified on 2025-04-25</p>]]>
      </description>
      
        <category>Crypto</category>
      
    </item>
    
  </channel>
</rss>
