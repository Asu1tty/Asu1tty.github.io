---
date: '2025-04-30T11:18:36+08:00'
draft: false
title: 'ELF结构及加载流程分析'
tags:
  - ELF

---

- - 目前，PC平台流行的 **可执行文件格式（Executable）** 主要包含如下两种：
    - Windows下的 **PE（Portable Executable）**
    - Linux下的 **ELF（Executable Linkable Format）**

    ELF（Executable and Linkable Format，可执行和可链接格式）是Linux系统中广泛使用的文件格式，用于存储可执行文件、目标代码、共享库和核心转储（core dump）。它是一种灵活、通用的格式，支持多种处理器架构和操作系统，具有跨平台特性。

    **主要特点：**
    - **跨平台支持**：ELF支持多种处理器架构（如x86、x86_64、ARM、MIPS）和字节序（大端/小端）。
    - **模块化设计**：分为多个段（Section）和节（Segment），便于解析和操作。
    - **支持动态链接**：允许在运行时加载共享库，减少内存占用。
    - **可扩展性**：支持添加自定义段，适应不同需求。

    ELF文件可以是以下几种类型：
    1. **可执行文件**（Executable File）：如编译后的程序，直接运行。
    2. **目标文件**（Object File）：编译器生成的中间文件，通常用于链接生成可执行文件。
    3. **共享库**（Shared Library）：动态链接库，运行时加载（如.so文件）。
    4. **核心转储**（Core Dump）：程序崩溃时保存的内存快照，用于调试。

    ## 1. ELF主要结构
    ELF 文件主要分为 3 个部分:
    - **ELF Header  ELF文件头**，位于ELF文件的开头，描述文件的整体信息。它的大小通常为32位系统中的52字节或64位系统中的64字节。
    - **Program Header Table  程序头表**  ，描述了文件中的**段**（Segment），主要用于运行时加载和执行。
    - **Section Header Table  节头表**  ，描述了文件中的**节**（Section），主要用于链接和调试。每个节包含特定类型的数据（如代码、数据、符号表等）。节头表对于可执行文件是可选的，但在目标文件中通常存在。

    ### 1.1. ELF Header  ELF文件头
    ```c
    //https://github.com/bminor/glibc/blob/glibc-2.27/elf/elf.h
    typedef struct
    {
      unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
      Elf32_Half	e_type;			/* Object file type */
      Elf32_Half	e_machine;		/* Architecture */
      Elf32_Word	e_version;		/* Object file version */
      Elf32_Addr	e_entry;		/* Entry point virtual address */
      Elf32_Off	e_phoff;		/* Program header table file offset */
      Elf32_Off	e_shoff;		/* Section header table file offset */
      Elf32_Word	e_flags;		/* Processor-specific flags */
      Elf32_Half	e_ehsize;		/* ELF header size in bytes */
      Elf32_Half	e_phentsize;		/* Program header table entry size */
      Elf32_Half	e_phnum;		/* Program header table entry count */
      Elf32_Half	e_shentsize;		/* Section header table entry size */
      Elf32_Half	e_shnum;		/* Section header table entry count */
      Elf32_Half	e_shstrndx;		/* Section header string table index */
    } Elf32_Ehdr;
    ```
    #### 1.1.1. e_ident[EI_NIDENT]

    | 宏名称     | 下标 | 目的           |
    | ---------- | ---- | -------------- |
    | EI_MAG0    | 0    | 文件标识       |
    | EI_MAG1    | 1    | 文件标识       |
    | EI_MAG2    | 2    | 文件标识       |
    | EI_MAG3    | 3    | 文件标识       |
    | EI_CLASS   | 4    | 文件类         |
    | EI_DATA    | 5    | 数据编码       |
    | EI_VERSION | 6    | 文件版本       |
    | EI_PAD     | 7    | 补齐字节开始处 |
    #### 1.1.2. e_ident[EI_MAG0…EI_MAG3]
    这是 ELF 文件的头 4 个字节，被称作 “魔数”，标识该文件是一个 ELF 目标文件。
    ELF文件的魔数为0x7f, 'E', 'L', 'F'，即字节序列7F 45 4C 46。
    0x7f被选为第一个字节，部分原因是它在ASCII编码中对应**DEL控制字符**，这是一个非打印字符，不太可能出现在文本文件或其他文件格式的开头，从而降低了误识别的风险。

    其他具体字段可以参考，[ELF文件](https://ctf-wiki.org/executable/elf/structure/basic-info)
    ### 1.2. Program Header Table  程序头表
    Program Header Table 是一个结构体数组，每一个元素的类型是 `Elf32_Phdr`，描述了一个段或者其它系统在准备程序执行时所需要的信息。其中，ELF 头中的 `e_phentsize` 和 `e_phnum` 指定了该数组每个元素的大小以及元素个数。一个目标文件的段包含一个或者多个节。**程序的头部只有对于可执行文件和共享目标文件有意义。**

    可以说，Program Header Table 就是专门为 ELF 文件运行时中的段所准备的。
    `Elf32_Phdr` 的数据结构如下
    ```c
    typedef struct
    {
      Elf32_Word	p_type;			/* Segment type */
      Elf32_Off	    p_offset;		/* Segment file offset */
      Elf32_Addr	p_vaddr;		/* Segment virtual address */
      Elf32_Addr	p_paddr;		/* Segment physical address */
      Elf32_Word	p_filesz;		/* Segment size in file */
      Elf32_Word	p_memsz;		/* Segment size in memory */
      Elf32_Word	p_flags;		/* Segment flags */
      Elf32_Word	p_align;		/* Segment alignment */
    } Elf32_Phdr;
    ```
    每个字段的说明如下

    | 字段     | 说明                                                         |
    | -------- | ------------------------------------------------------------ |
    | p_type   | 该字段为段的类型，或者表明了该结构的相关信息。               |
    | p_offset | 该字段给出了从文件开始到该段开头的第一个字节的偏移。         |
    | p_vaddr  | 该字段给出了该段第一个字节在内存中的虚拟地址。               |
    | p_paddr  | 该字段仅用于物理地址寻址相关的系统中， 由于 “System V” 忽略了应用程序的物理寻址，可执行文件和共享目标文件的该项内容并未被限定。 |
    | p_filesz | 该字段给出了文件镜像中该段的大小，可能为 0。                 |
    | p_memsz  | 该字段给出了内存镜像中该段的大小，可能为 0。                 |
    | p_flags  | 该字段给出了与段相关的标记。                                 |
    | p_align  | 可加载的程序的段的 p_vaddr 以及 p_offset 的大小必须是 page 的整数倍。该成员给出了段在文件以及内存中的对齐方式。如果该值为 0 或 1 的话，表示不需要对齐。除此之外，p_align 应该是 2 的整数指数次方，并且 p_vaddr 与 p_offset 在模 p_align 的意义下，应该相等。 |
    ### 1.3. Section Header Table  节头表
    该结构用于定位 ELF 文件中的每个节区的具体位置。
    首先，ELF 头中的 `e_shoff` 项给出了从文件开头到节头表位置的字节偏移。`e_shnum` 告诉了我们节头表包含的项数；`e_shentsize` 给出了每一项的字节大小。

    | 成员         | 说明                                                         |
    | ------------ | ------------------------------------------------------------ |
    | sh_name      | 节名称，是节区头字符串表节区中（Section Header String Table Section）的索引，因此该字段实际是一个数值。在字符串表中的具体内容是以 NULL 结尾的字符串。 |
    | sh_type      | 根据节的内容和语义进行分类，具体的类型下面会介绍。           |
    | sh_flags     | 每一比特代表不同的标志，描述节是否可写，可执行，需要分配内存等属性。 |
    | sh_addr      | 如果节区将出现在进程的内存映像中，此成员给出节区的第一个字节应该在进程镜像中的位置。否则，此字段为 0。 |
    | sh_offset    | 给出节区的第一个字节与文件开始处之间的偏移。SHT_NOBITS 类型的节区不占用文件的空间，因此其 sh_offset 成员给出的是概念性的偏移。 |
    | sh_size      | 此成员给出节区的字节大小。除非节区的类型是 SHT_NOBITS ，否则该节占用文件中的 sh_size 字节。类型为 SHT_NOBITS 的节区长度可能非零，不过却不占用文件中的空间。 |
    | sh_link      | 此成员给出节区头部表索引链接，其具体的解释依赖于节区类型。   |
    | sh_info      | 此成员给出附加信息，其解释依赖于节区类型。                   |
    | sh_addralign | 某些节区的地址需要对齐。例如，如果一个节区有一个 doubleword 类型的变量，那么系统必须保证整个节区按双字对齐。也就是说，sh_addr%sh_addralignsh_addr%sh_addralign=0。目前它仅允许为 0，以及 2 的正整数幂数。 0 和 1 表示没有对齐约束。 |
    | sh_entsize   | 某些节区中存在具有固定大小的表项的表，如符号表。对于这类节区，该成员给出每个表项的字节大小。反之，此成员取值为 0。 |

    ### 1.4. 常见的节（sections）
    #### 1.4.1. .text 节
    `.text` 节是保存了程序代码指令的**代码节**。**一段可执行程序，如果存在 Phdr，则 `.text` 节就会存在于 `text` 段中**。由于 `.text` 节保存了程序代码，所以节类型为 `SHT_PROGBITS` 。
    #### 1.4.2. .rodata 节
    `rodata` 节保存了只读的数据，如一行 C 语言代码中的字符串。由于 `.rodata` 节是只读的，所以只能存在于一个可执行文件的**只读段**中。因此，只能在 `text` 段（不是 `data` 段）中找到 `.rodata` 节。由于 `.rodata` 节是只读的，所以节类型为 `SHT_PROGBITS` 。
    #### 1.4.3. .plt（Procedure Linkage Table） 节（过程链接表）
    用于延迟绑定，其包含了动态链接器调用从共享库导入的函数所必需的相关代码。由于 .plt 节保存了代码，所以节类型为 `SHT_PROGBITS `。
    #### 1.4.4. .data 节
    `.data` 节存在于`data`段中，存储已初始化的全局变量和静态变量。由于 .data 节保存了程序的变量数据，所以节类型为 `SHT_PROGBITS` 。
    #### 1.4.5. .bss 节
    `.bss` 节存在于 `data` 段中，占用空间不超过 4 字节，仅表示这个节本身的空间。`.bss` 节存储未初始化的全局变量和静态变量（不占用文件空间，仅在内存中分配）。·程序加载时数据被初始化为 0，在程序执行期间可以进行赋值。由于 `.bss` 节未保存实际的数据，所以节类型为 `SHT_NOBITS` 。
    #### 1.4.6. .got.plt 节
    `.got.plt`节是ELF文件中一个特定的节，通常出现在动态链接的ELF文件中，用于存储与过程链接表（`.plt`）相关的全局偏移表条目。它主要服务于延迟绑定机制，即在程序运行时动态解析外部符号（如共享库中的函数）的地址。`.got.plt` 是全局偏移表（`.got`）的一个子集，专门为`.plt`中的函数调用提供地址解析支持。
    #### 1.4.7. .dynsym 节
    `.dynsym` 节保存在 `text` 段中。**其保存了从共享库导入的动态符号表**。`.dynsym` 可能包含 `printf`、`memcpy` 等 `libc` 函数的符号。节类型为 `SHT_DYNSYM` 。
    #### 1.4.8. .dynstr 节（动态链接字符串表）
    `.dynstr` 保存了动态链接字符串表，表中存放了一系列字符串，这些字符串代表了符号名称，以空字符作为终止符。
    #### 1.4.9. .rel.* 节（重定位表）
    重定位表保存了重定位相关的信息，这些信息描述了如何在链接或运行时，对 ELF 目标文件的某部分或者进程镜像进行补充或修改。由于重定位表保存了重定位相关的数据，所以节类型为 SHT_REL 。
    #### 1.4.10. .symtab 节（符号表）
    `.symtab` 节是一个 `ElfN_Sym` 的数组，保存了符号信息。节类型为 `SHT_SYMTAB` 。
    #### 1.4.11. .strtab 节（字符串表） 
    `.strtab` 节保存的是符号字符串表，表中的内容会被 `.symtab` 的 `ElfN_Sym` 结构中的 `st_name` 引用。节类型为 `SHT_STRTAB` 。
    #### 1.4.12. .ctors 节和.dtors 节
    `.ctors` （构造器）节和 `.dtors` （析构器）节分别保存了指向构造函数和析构函数的函数指针，构造函数是在 main 函数执行之前需要执行的代码；析构函数是在 main 函数之后需要执行的代码。
    ### 1.5. 符号表
    **符号是对某些类型的数据或代码（如全局变量或函数）的符号引用，函数名或变量名就是符号名**。

    例如， `printf()` 函数会在动态链接符号表 `.dynsym` 中存有一个指向该函数的符号项（以 `Elf_Sym` 数据结构表示）。在大多数共享库和动态链接可执行文件中，存在两个符号表。即 `.dynsym` 和 `.symtab` 。

    `.dynsym` 保存了引用来自外部文件符号的全局符号。如 `printf` 库函数。 `.dynsym` 保存的符号是 `.symtab` 所保存符合的子集， `.symtab` 中还保存了可执行文件的本地符号。如全局变量，代码中定义的本地函数等。

    **既然 `.dynsym` 是 `.symtab` 的子集，那为何要同时存在两个符号表呢？**

    `.symtab` 存储ELF文件中所有符号的完整信息，包括函数、变量、常量等的名称、地址、类型和绑定属性，依赖`.strtab`（静态字符串表）存储符号名称。通常较大，包含所有符号（包括动态链接不需要的符号）。
    而 `.dynsym` 存储动态链接所需的符号信息，是 `.symtab` 的子集 ，依赖 `.dynstr`（动态字符串表）存储符号名称，仅包含动态链接过程中需要的符号。
    ### 1.6. 字符串表
    类似于符号表，在大多数共享库和动态链接可执行文件中，也存在两个字符串表。即 `.dynstr` 和 `.strtab` ，分别对应于 `.dynsym` 和 `symtab` 。此外，还有一个 `.shstrtab` 的节头字符串表，用于保存节头表中用到的字符串，可通过 `sh_name` 进行索引。
    ### 1.7. 重定位表
    **重定位就是将符号定义和符号引用进行连接的过程**。可重定位文件需要包含描述如何修改节内容的相关信息，从而使可执行文件和共享目标文件能够保存进程的程序镜像所需要的正确信息。 重定位表是进行重定位的重要依据。我们可以使用 objdump 工具查看目标文件的重定位表：

    ```
    $ objdump -r hello.o
    
    
    hello.o:     file format elf64-x86-64
    
    RELOCATION RECORDS FOR [.text]:
    OFFSET           TYPE              VALUE
    0000000000000005 R_X86_64_32       .rodata
    000000000000000a R_X86_64_PC32     puts-0x0000000000000004
    
    
    RELOCATION RECORDS FOR [.eh_frame]:
    OFFSET           TYPE              VALUE
    0000000000000020 R_X86_64_PC32     .text
    ```
    重定位表是一个 Elf_Rel 类型的数组结构，每一项对应一个需要进行重定位的项。 其成员含义如下表所示：

    | 成员                                       | 含义                                                         |
    | ------------------------------------------ | ------------------------------------------------------------ |
    | r_offset                                   | 重定位入口的偏移。对于可重定位文件来说，这个值是该重定位入口所要修正的位置的第一个字节相对于节起始的偏移；对于可执行文件或共享对象文件来说，这个值是该重定位入口所要修正的位置的第一个字节的虚拟地址 |
    | r_info                                     | 重定位入口的类型和符号。因为不同处理器的指令系统不一样，所以重定位所要修正的指令地址格式也不一样。每种处理器都有自己的一套重定位入口的类型。对于可执行文件和共享目标文件来说，它们的重定位入口是动态链接类型的。 |
    | 重定位是目标文件链接成为可执行文件的关键。 |                                                              |

    ## 2. ELF 的链接过程
    ### 2.1. 链接概述
    链接是将多个目标文件（由编译器生成，包含机器码和数据，但地址通常是相对的或未确定的）和库文件组合在一起，生成一个最终的可执行文件、共享库或静态库的过程。链接器的主要任务包括：
    - **符号解析 (Symbol Resolution):** 确定代码中使用的函数或变量（符号）的定义在哪里。例如，在一个目标文件中调用了 `printf` 函数，链接器需要在某个库中找到 `printf` 的实际代码位置。
    - **重定位 (Relocation):** 调整代码和数据的地址。目标文件通常是相对于一个起始地址编译的，链接器需要将这些相对地址修正为最终程序在内存中的实际地址。
    如下图所示为最基本的静态链接过程示意图。每个模块的源代码文件（如 .c ）文件经过编译器编译成**目标文件**（Object File，一般扩展名为 .o 或 .obj ）。目标文件和 库（Library） 一起链接形成最终的可执行文件。

    其中，最常见的库就是**运行时库（Runtime Library）**，它是支持程序运行的基本函数的集合。库本质上是一组目标文件的包，由一些最常用的代码编译成目标文件后打包而成。
    ![](https://cdn.jsdelivr.net/gh/Asu1tty/blog_img@master/picSource/linking-process.png)

    链接过程主要包含了三个步骤：
    1. **地址与空间分配（Address and Storage Allocation）**
    2. **符号解析（Symbol Resolution）**
    3. **重定位（Relocation）**
    下面，我们以两个源代码文件 `a.c` 和 `b.c` 为例展开分析。

    ```
    // a.c
    extern int shared;
    
    int main() {
        int a = 100;
        swap(&a, &shared);
    }
    // b.c
    int shared = 1;
    
    void swap(int *a, int *b) {
        *a ^= *b ^= *a ^= *b;
    }
    ```

    其中， `b.c` 中定义了两个全局符号：变量 `shared` 、函数 `swap` ； `a.c` 中定义了一个全局符号： `main` 。 `a.c` 引用了 `b.c` 中的 `swap` 和 `shared` 。接下来我们要将两个目标文件链接在一起并最终形成一个执行程文件 `ab` 。

    使用 `gcc -c` 命令我们可以分别编译得到 `a.o` 和 `b.o` 两个目标文件。
    #### 2.1.1. 地址与空间分配
    ##### 2.1.1.1. 按序叠加
    一个最简单的方案就是将输入的文件按序叠加，如下图所示。
    ![](https://cdn.jsdelivr.net/gh/Asu1tty/blog_img@master/picSource/elf-simple-merge.png)

    虽然这种方法非常简单，但是它存在一个问题：在有很多输入文件的情况下，输出文件会有很多零散的节。这种做法非常浪费空间，因为每个节都需要有一定的地址和空间对齐要求。x86 硬件的对齐要求是 4KB。如果一个节的大小只有 1 个字节，它也要在内存在重用 4KB。这样会造成大量内部碎片。所以不是一个好的方案。
    ##### 2.1.1.2. 合并相似节
    一个更加实际的方法便是合并相同性质的节，比如：将所有输入文件的 **`.text` 节**合并到输出文件的 **`text` 段**（注意，此时出现了段和节两个概念），如下图所示。
    ![](https://cdn.jsdelivr.net/gh/Asu1tty/blog_img@master/picSource/elf-similar-merge.png)
    其中 `.bss` 节在目标文件和可执行文件中不占用文件的空间，但是它在装载时占用地址空间。事实上，这里的空间和地址有两层含义:
    1. 在输出的可执行文件中的空间
    2. 在装载后的虚拟地址中的空间
    对于有实际数据的节，如 `.text` 和 `.data` ，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；对于 `.bss` 来，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。我们在这里谈到的空间分配只关注于虚拟地址空间的分配，因为这关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间分配与链接的关系并不大。 现在的链接器空间分配的策略基本上都采用 “合并相似节” 的方法，使用这种方法的链接器一般采用一种叫 **两步链接（Two-pass Linking）** 的方法。即整个链接过程分为两步：
    - **第一步 地址与空间分配**
    扫描所有的输入目标文件，获得它们的各个节的长度、属性、位置，并将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局的符号表。这一步，链接器能够获得所有输入目标文件的节的长度，并将它们合并，计算出输出文件中各个节合并后的长度与位置，并建立映射关系。
    - **第二步 符号解析与重定位**
    使用前一步中收集到的所有信息，读取输入文件中节的输数据、重定位信息，并且进行符号解析与重定位、调整代码、调整代码中的地址等。事实上，第二步是链接过程的核心，尤其是重定位。
    ![](https://cdn.jsdelivr.net/gh/Asu1tty/blog_img@master/picSource/two-step-linking.png)
    在地址与空间分配步骤完成之后，相似权限的节会被合并成段，并生成了 [ELF 文件结构](http://chuquan.me/2018/05/21/elf-introduce/)一文中没有介绍的 **程序头表（Program Header Table）** 结构。如下右图可执行文件结构所示，主要生成两个段：代码段（ `text` 段）、数据段（ `data` 段 ）。
    ![](https://cdn.jsdelivr.net/gh/Asu1tty/blog_img@master/picSource/different-elf-type.png)
    我们使用 ld 或 gcc 将 `a.o` 和 `b.o` 链接起来，然后使用 objdump 工具来查看链接前后的地址分配情况。

    ```
    $ objdump -h a.o
    
    Sections:
    Idx Name          Size      VMA               LMA               File off  Algn
      0 .text         0000004f  0000000000000000  0000000000000000  00000040  2**0
                      CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
      1 .data         00000000  0000000000000000  0000000000000000  0000008f  2**0
                      CONTENTS, ALLOC, LOAD, DATA
      2 .bss          00000000  0000000000000000  0000000000000000  0000008f  2**0
                      ALLOC
      ...
    $ objdump -h b.o
    
    Sections:
    Idx Name          Size      VMA               LMA               File off  Algn
      0 .text         0000004b  0000000000000000  0000000000000000  00000040  2**0
                      CONTENTS, ALLOC, LOAD, READONLY, CODE
      1 .data         00000004  0000000000000000  0000000000000000  0000008c  2**2
                      CONTENTS, ALLOC, LOAD, DATA
      2 .bss          00000000  0000000000000000  0000000000000000  00000090  2**0
                      ALLOC
      ...
    $ objdump -h ab
    
    Sections:
    Idx Name          Size      VMA               LMA               File off  Algn
      ...
      13 .text         00000202  0000000000400450  0000000000400450  00000450  2**4
                      CONTENTS, ALLOC, LOAD, READONLY, CODE
      ...
      24 .data         00000014  0000000000601028  0000000000601028  00001028  2**3
                      CONTENTS, ALLOC, LOAD, DATA
      25 .bss          00000004  000000000060103c  000000000060103c  0000103c  2**0
                      ALLOC
      ...
    ```

    可以发现，链接前目标文件中所有节的 **VMA（Virtual Memory Address）** 都是 0，因为虚拟空间还没有分配。链接后，可执行文件 `ab` 中各个节被分配到了相应的虚拟地址，如 `.text` 节被分配到了地址 `0x0000000000400450` 。

    那么，为什么链接器要将可执行文件 `ab` 的 `.text` 节分配到 `0x0000000000400450` ？而不是从虚拟空间的 0 地址开始分配呢？这涉及到操作系统的进程虚拟地址空间的分配规则。在 Linux x86-64 系统中，代码段总是从 `0x0000000000400000` 开始的，另外 `.text` 节之前还有 `ELF Header` 、 `Program Header Table` 、 `.init` 等占用了一定的空间，所以就被分配到了 `0x0000000000400450` 。
    #### 2.1.2. 符号解析
    - 动态链接器在可执行文件和共享库的符号表中查找符号定义。
    - 对于未解析的符号引用，动态链接器搜索依赖的共享库，找到对应的定义。
    - 如果符号在多个库中定义，动态链接器按搜索顺序（通常由 LD_LIBRARY_PATH 或默认路径决定）选择第一个匹配的定义。
    #### 2.1.3. 重定位
    - 由于共享库的加载地址在运行时确定，代码和数据中的地址引用需要调整。
    - 动态链接器使用重定位表（.rela.dyn 用于数据，.rela.plt 用于函数）中的信息进行地址修正。
    - 常见重定位类型：
        - R_X86_64_GLOB_DAT：调整全局数据的地址。
        - R_X86_64_JUMP_SLOT：调整函数调用的地址，与PLT和GOT配合使用。

    ### 2.2. 静态链接
    事实上，静态链接的过程就是上文所描述的过程。在 Linux 中，静态链接器（static linker） `ld` 以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的节组成，每一节都是一个连续的字节序列。

    ### 2.3. 动态链接
    #### 2.3.1. 动态链接的基本实现
    动态链接涉及运行时的链接以及多个文件的装载，必需要有操作系统的支持。因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。

    目前，主流操作系统都支持动态链接。在 Linux 中，ELF 动态链接文件被称为 **动态共享对象（DSO，Dynamic Shared Objects）**，一般以 `.so` 为后缀；在 Windows 中，动态链接文件被称为 **动态链接库（Dynamic Linking Library）**，一般以 `.dll` 为后缀。

    在 Linux 中，常用的 C 语言库的运行库 glibc，其动态链接形式的版本保留在 `/lib` 目录下，文件名为 `libc.so` 。整个系统只保留一份 C 语言动态链接文件 `libc.so` ，所有的 C 语言编写的、动态链接的程序都可以在运行时使用它。当程序被装载时，系统的**动态链接器**会将程序所需要的所有动态链接库装载到进程的地址空间，并将程序中所有未解析的符号绑定到相应的动态链接库中，并进行重定位。

    #### 2.3.2. 动态链接程序运行时地址空间分布
    对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，即可执行文件。而对于动态链接，除了可执行文件，还有它所依赖的共享目标文件。 

    关于共享目标文件在内存中的地址分配，主要有两种解决方案，分别是：

    - **静态共享库（Static Shared Library）**（地址固定）
    - **动态共享库（Dynamic Shared Libary）**（地址不固定）

    ##### 2.3.2.1. 静态共享库
    静态共享库的做法是将程序的各个模块统一交给操作系统进行管理，操作系统在某个特定的地址划分出一些地址块，为那些已知的模块预留足够的空间。因为这个地址对于不同的应用程序来说，都是固定的，所以称之为`静态`。

    但是静态共享库的目标地址会导致地址冲突、升级等问题。

    ##### 2.3.2.2. 动态共享库
    采用动态共享库的方式，也称为**装载时重定位（Load Time Relocation）**。其基本思路是：**在链接时，对所有绝对地址的引用都不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。**

    但是这种方式也存在一些问题。比如，动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来说都是不同的。 

    虽然，动态链接库中的代码是共享的，但是其中的可修改数据部分对于不同进程来说是由多个副本的。基于此，一种名为地址无关代码的技术被提出以克服这个问题。

    ##### 2.3.2.3. 地址无关代码
    **地址无关代码（Position-Independent Code, PIC）** 是一种编译技术，用于生成能够在内存中任意位置正确运行的机器码，而无需依赖特定的绝对地址。这种技术在动态链接中尤为重要，尤其是在共享库（例如 `.so` 文件）的实现中。以下是对PIC技术的详细介绍，以及它在动态链接中的关键作用。
    ###### 2.3.2.3.1. PIC原理
    PIC通过以下机制实现地址无关性：
    1. **相对寻址 (Relative Addressing):** 对于代码内部的跳转（如条件跳、循环），不是跳转到绝对地址，而是跳转到相对于当前指令指针 (Instruction Pointer, IP 或 RIP) 的偏移量。例如，jmp +100 表示跳到当前指令后的100个字节处。这种方式天然就是位置无关的。
       
    2. **间接寻址 (Indirect Addressing) 通过全局偏移表 (Global Offset Table, GOT):** 对于访问全局变量、静态变量或者调用外部函数，PIC 代码不会直接使用它们的绝对地址。它会通过一个特殊的表——**全局偏移表 (Global Offset Table, GOT)** 来间接访问。GOT 是一张由地址组成的表，它包含了程序或库需要访问的所有全局数据和函数入口点的实际内存地址。
       
        - PIC 代码会先计算出 GOT 表在内存中的位置（这通常可以通过相对于当前指令指针的偏移来完成，因为 GOT 表通常位于代码段或数据段附近）。
        - 然后，它通过计算目标变量或函数在 GOT 表中的**偏移量**来找到对应的 GOT 条目。
        - GOT 条目中存储的才是目标变量或函数的**实际**运行时内存地址。
        - 代码通过读取 GOT 条目的内容来获取实际地址，然后再进行访问或调用。
        
    3. **通过过程链接表 (Procedure Linkage Table, PLT):** 对于调用外部函数，通常会结合使用 PLT 和 GOT。PLT 是一小段代码存根 (stub) 的集合。
       
        - 当 PIC 代码调用一个外部函数时，它会跳转到该函数在 PLT 中的对应存根。
        - PLT 存根的第一步通常是跳转到其对应的 GOT 条目。
        - GOT 条目最初可能包含一个指向动态链接器解析代码的地址。
        - 第一次调用时，PLT 将控制权交给动态链接器，动态链接器负责查找目标函数的实际地址（例如，在另一个共享库中），然后将这个实际地址写入到对应的 GOT 条目中。
        - 之后的调用，PLT 存根就会直接通过已经被更新的 GOT 条目跳转到目标函数的实际地址，效率更高。

    #### 2.3.3. 详细的动态链接中PLT和GOT的作用
    动态链接中，**PLT（Procedure Linkage Table，过程链接表）** 和 **GOT（Global Offset Table，全局偏移表）** 是实现延迟绑定（lazy binding）和符号重定位的核心结构。
    **GOT（全局偏移表）**：
    - GOT 是一个表格，记录全局符号（如函数和变量）的地址。
    - 程序启动时，GOT 中的条目初始指向 PLT 或动态链接器的解析函数。
    - 符号解析后，GOT 被更新为实际地址。
    **PLT（过程链接表）**：
    - PLT 是一个跳转表，每个条目对应一个外部函数。
    - 初始时，PLT 条目指向动态链接器的解析函数。
    - 当函数首次调用时：
        1. PLT 调用动态链接器解析函数地址。
        2. 动态链接器将实际地址写入 GOT。
        3. PLT 更新为直接跳转到 GOT 中的地址。
    - 后续调用直接通过 GOT 跳转到函数地址，无需再次解析。
    这种延迟绑定机制推迟了符号解析到第一次调用时，显著减少了程序启动的开销。

    ## 3. ELF 的装载过程
    当我们在 Linux 的 bash 中输入命令执行某个 ELF 可执行文件时，如下所示。
    ```
    $ ./hello.out
    ```
    那么，Linux 系统是如何装载该 ELF 文件并执行的呢？这个过程可以分为以下这些步骤：
    - 创建新进程
    - 检查可执行文件类型
    - 搜索匹配装载处理过程
    - 装载执行可执行文件
    ### 3.1. 创建新进程
    首先在用户层面，bash 进程会调用 `fork()` 系统调用创建一个新的进程。其次，新的进程通过调用 `execve()` 系统调用来执行指定的 ELF 文件。原先的 bash 进程继续返回并等待刚才启动的新进程结束，之后继续等待用户输入命令。

    `execve()` 系统调用被定义在 `unistd.h` ，其原型如下所示。其中的三个参数分别对应被执行程序的 程序文件名、执行参数、环境变量。

    ```
    int execve(const char *filename, char *const argv[], char *const envp[]);
    ```

    ### 3.2. 检查可执行文件类型
    当进入 `execve()` 系统调用之后，Linux 内核就开始进行真正的装载工作。在内核中， `execve()` 系统调用相应的入口是 `sys_execve()` 。 `sys_execve()` 进行一些参数的检查复制之后，调用 `do_execve()` 。 `do_execve()` 会首先查找被执行的文件，如果找到文件，则读取文件的前 128 个字节。

    为什么要先读取文件的前 128 个字节？这是因为 Linux 支持的可执行文件不止 ELF 一种，还包括 **a.out**、**Java 程序**、**以 `#!` 开头的脚本程序**。 `do_execve()` 通过读取前 128 个字节来判断文件的格式。每种可执行文件格式的开头几个字节都是很特殊的，尤其是前 4 个字节，被称为 **魔数（Magic Number）**。比如：ELF 的可执行文件格式的头 4 个字节为 `0x7F` 、 `e` 、 `l` 、 `f` ；Java 的可执行文件格式的头 4 个字节为 `c` 、 `a` 、 `f` 、 `e` ；如果是解释型语言的脚本，则第一行通常是 `#!/bin/sh` 或 `#!/user/bin/python` ，其中 `#` 和 `!` 构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序的路径。

    ### 3.3. 搜索匹配装载处理过程
    当 `do_execve()` 读取了 128 个字节的文件头部之后，调用 `search_binary_handle()` 去搜索和匹配合适的可执行文件装载处理过程。**Linux 中所有被支持的可执行文件格式都有相应的装载处理过程**， `search_binary_handler()` 会通过判断头部的魔术确定文件的格式，并且调用相应的装载处理过程。常见的可执行程序及其装载处理过程的对应关系如下所示.

    - ELF 可执行文件： `load_elf_binary()`
    - a.out 可执行文件： `load_aout_binary()`
    - 可执行脚本程序： `load_script()`
    ### 3.4. 装载执行可执行文件
    以 ELF 的装载处理过程 `load_elf_binary()` 为例，其所包含的步骤如下图所示：
    ![](https://cdn.jsdelivr.net/gh/Asu1tty/blog_img@master/picSource/executable-file-load-process.png)
    1. 操作系统读取可执行文件 ELF 的 `Header`，检查文件的有效性。
    2. 操作系统读取可执行文件 ELF的 `Program Header Table` 中读取每个 `Segment` 的虚拟地址、文件地址、属性等。
    3. 操作系统根据 `Program Header Table` 将可执行文件 ELF 映射至内存。
    4. 如果是静态链接的情况，则直接跳转至第 7 步；如果是动态链接的情况，操作系统将查找 `.interp` 节，找到 **动态链接器（Dynamic Linker）** 的位置，并启动动态链接器。在 Linux 下，动态链接器 `ld.so` 是一个共享对象，操作系统同样通过映射的方式将它加载到进程的地址空间。操作系统在加载完后，将控制权交给动态链接器的入口。
    5. 动态链接器获得控制权后，开始执行一系列初始化操作。
    6. 动态链接器根据当前的环境参数，对可执行文件进行动态链接工作。
    7. 控制权被转交到可执行文件的入口地址，程序开始正式执行。

    ## 4. 详细ELF装载过程
    ELF 文件不仅仅用于可执行程序，还用于共享库、目标文件（编译中间产物）和核心转储文件。这里的装载主要指**可执行程序**或**共享库**在被运行或使用时，从磁盘加载到内存并准备执行的过程。

    这个过程主要由 **操作系统内核** 的一部分（通常称为 **程序加载器** 或 **execve 处理程序**）以及 **动态链接器/加载器**（一个用户空间的共享库，通常是 `/lib/ld-linux.so.x`）协同完成。

    整个过程大致可以分为以下几个主要阶段：

    **阶段 1: `execve()` 系统调用和内核的初始处理**

    1.  **程序启动:** 当你在 shell 中输入一个命令（例如 `ls`）并按回车时，shell 会调用 `fork()` 创建一个子进程，然后在子进程中调用 `execve("/bin/ls", {"ls", ...}, {环境变量...})` 系统调用。
    2.  **进入内核:** `execve()` 系统调用是用户空间进入内核空间的入口点。内核接管控制权。
    3.  **权限检查:** 内核首先检查当前用户是否有执行指定文件（`/bin/ls`）的权限。
    4.  **文件类型识别:** 内核打开指定的文件，读取文件头部（通常是最初的几十个字节）。内核通过检查文件的**魔数 (Magic Number)** 来识别文件类型。对于 ELF 文件，魔数是 `0x7f` 后跟着 ASCII 字符 `'E'`, `'L'`, `'F'` (即 `\x7fELF`)。内核还会读取 ELF 头部的 `e_ident[EI_CLASS]` (32位或64位) 和 `e_type` (可执行文件 `ET_EXEC` 或动态可执行文件 `ET_DYN`/PIE)。
    5.  **确定处理程序:** 内核根据识别出的文件类型，找到相应的处理程序。对于 ELF 可执行文件，内核知道如何处理它。

    **阶段 2: 内核加载 ELF 段 (Segments)**

    内核的主要职责是根据 ELF 文件的**程序头表 (Program Header Table)** 来建立进程的虚拟地址空间布局，并将文件中的内容映射到对应的虚拟地址上。

    1.  **读取程序头表:** 内核读取 ELF 头部中的 `e_phoff` (程序头表偏移量)、`e_phnum` (程序头表条目数量) 和 `e_phentsize` (每个条目大小)，然后读取整个程序头表到内核内存中。
    2.  **处理 `PT_INTERP` (解释器) 段:**
        *   如果 ELF 文件的程序头表中存在 `PT_INTERP` 类型的段，这表明这是一个**动态链接**的可执行文件。`PT_INTERP` 段的内容是一个字符串，指定了用于解析和加载共享库的动态链接器/加载器程序的路径（例如 `/lib/ld-linux.so.x`）。
        *   内核会**加载**这个动态链接器（它本身也是一个 ELF 共享库文件），将其映射到进程的虚拟地址空间中。
        *   如果不存在 `PT_INTERP` 段，则这是一个**静态链接**的可执行文件，内核将跳过动态链接器加载步骤。
    3.  **处理 `PT_LOAD` 段:**
        *   这是最重要的段类型。`PT_LOAD` 段描述了文件中需要被映射到内存的连续区域。一个典型的 ELF 可执行文件至少有两个 `PT_LOAD` 段：
            *   **Text Segment:** 包含程序代码 (`.text` section) 和只读数据 (`.rodata` section)。它通常被映射为**只读 + 可执行** (`PROT_READ | PROT_EXEC`)。
            *   **Data Segment:** 包含已初始化数据 (`.data` section) 和未初始化数据 (`.bss` section)。它通常被映射为**可读写** (`PROT_READ | PROT_WRITE`)。`.bss` 部分在映射后会被清零。
        *   对于每个 `PT_LOAD` 段，内核根据程序头表中指定的内存地址 (`p_vaddr`) 和文件偏移量 (`p_offset`)，使用内存映射机制（例如 `mmap` 系统调用）将文件中的相应部分**映射**到进程的虚拟地址空间中。
        *   注意：内核在这里进行的是**文件到内存的映射**，而不是简单地将整个文件内容读入内存。实际的物理页面只在首次访问时按需加载（页错误机制）。
        *   内核还会根据 `p_flags` 设置内存页面的访问权限（读、写、执行）。
    4.  **处理其他类型的段:** 内核还会处理其他一些段，例如：
        *   `PT_DYNAMIC`: 指向 `.dynamic` 段，包含动态链接所需的信息（库依赖、符号信息、重定位信息等）。内核将此段映射到内存，但不解析其内容，这是动态链接器的工作。
        *   `PT_GNU_STACK`: 控制栈的执行权限（通常是不可执行的，为了安全）。
        *   `PT_TLS`: 线程本地存储数据。
        *   等等。
    5.  **设置栈:** 内核为新进程设置用户空间的栈。它会将命令行参数 (`argv`)、环境变量 (`envp`) 以及一个重要的结构——**辅助向量 (Auxiliary Vector, AuxV)** 压入栈顶。AuxV 包含了内核传递给用户空间加载器（特别是动态链接器）的关键信息，例如页面大小、程序入口点地址、`PT_DYNAMIC` 段的位置、动态链接器的入口点地址等。

    **阶段 3: 将控制权转移给动态链接器 (仅针对动态链接程序)**

    如果程序是动态链接的（即存在 `PT_INTERP`），在内核完成自身的映射工作后，它不会直接跳转到主程序的入口点。相反，内核会将处理器的指令指针 (`RIP` 或 `EIP`) 设置为**动态链接器**的入口点地址（从动态链接器的 ELF 头部 `e_entry` 获取）。

    1.  **动态链接器启动:** 动态链接器（`ld-linux.so`）现在开始执行。它运行在用户空间，但拥有完成动态链接所需的特权（例如调用 `mmap` 加载更多库）。
    2.  **解析 AuxV 和环境:** 动态链接器首先解析栈上的 AuxV 和环境变量，获取它工作所需的信息（如主程序信息、搜索路径 `LD_LIBRARY_PATH` 等）。
    3.  **加载所需的共享库:** 动态链接器读取主程序和已加载库的 `.dynamic` 段（通过 AuxV 或 `PT_DYNAMIC` 找到）。它遍历 `DT_NEEDED` 条目，确定程序依赖的所有共享库。
        *   对于每个依赖的库，动态链接器使用预定的搜索路径（包括 `LD_LIBRARY_PATH` 环境变量、`/etc/ld.so.conf` 配置、默认系统路径等）在文件系统中查找对应的库文件。
        *   找到库文件后，动态链接器重复内核对主程序和自身的操作：打开库文件，读取其程序头表，并使用 `mmap` 将库的 `PT_LOAD` 段映射到进程的虚拟地址空间。由于 ASLR (地址空间布局随机化)，这些库通常会被加载到随机的地址。这就是**位置无关代码 (PIC)** 如此重要的原因，它允许库被加载到任意地址而无需修改代码本身。
        *   这个过程是递归的：如果一个被加载的库依赖于其他库，动态链接器会继续查找并加载这些库，直到所有依赖关系都被满足。
        *   动态链接器还会处理 `LD_PRELOAD` 环境变量，优先加载其中指定的库。
    4.  **执行重定位 (Relocations):** 这是动态链接最核心的部分。
        *   程序的代码和数据中包含许多对符号（函数、变量）的引用，这些符号可能定义在主程序自身或其依赖的共享库中。
        *   在编译和链接时，这些符号的地址是不知道的，或者只是临时的占位符。ELF 文件中的**重定位节 (Relocation Sections)**（如 `.rela.dyn`, `.rela.plt`）记录了所有需要修补的地址和对应的符号信息。
        *   动态链接器遍历这些重定位信息：
            *   **数据重定位:** 对于对全局/静态变量的引用，动态链接器计算这些变量在内存中的最终地址（根据它们所在的段被映射的地址），然后将这个实际地址写入到需要引用它的位置（通常是 `.got` 全局偏移表或直接在数据段中）。
            *   **函数重定位 (PLT/GOT):** 对于对外部函数的调用，动态链接器初始化 **过程链接表 (PLT)** 和 **全局偏移表 (GOT)**。通常，PLT 条目会通过 GOT 条目跳转。动态链接器会将 GOT 中对应外部函数的条目初始化为一个特殊地址，这个地址指向动态链接器内部的一个函数，负责查找符号的实际地址。当程序第一次调用该函数时，控制权会回到动态链接器，它查找符号的实际地址（使用符号表 `.dynsym` 和版本信息），然后将这个实际地址写入 GOT 条目中，并跳转到目标函数。随后的调用就可以直接通过 GOT 跳转，无需再次查找（这称为**延迟绑定**或**惰性绑定**，Lazy Binding，是默认行为，可以通过 `LD_BIND_NOW=1` 强制立即绑定）。
    5.  **运行初始化函数:** 在所有库加载完毕并完成重定位后，动态链接器会调用主程序和所有已加载共享库的初始化函数。这些函数通常由编译器生成，用于设置程序运行环境，例如 C++ 的全局对象构造函数。这些函数通常通过 `.init` 节或 `DT_INIT`/`DT_INIT_ARRAY` 条目在 `.dynamic` 段中指定。

    **阶段 4: 将控制权转移给主程序**

    1.  **跳转到程序入口点:** 在动态链接器完成所有加载、重定位和初始化工作后，它会将处理器的指令指针设置为**主程序**的入口点地址。这个地址通常是 C 运行时库的 `_start` 函数（而不是 `main` 函数），并且这个地址是通过 AuxV (`AT_ENTRY`) 从内核那里获取的。

    **阶段 5: 程序执行**

    1.  **`_start` 执行:** C 运行时库的 `_start` 函数会进行一些最后的设置（例如初始化标准 I/O），然后调用用户的 `main()` 函数。
    2.  **程序运行:** `main()` 函数开始执行，程序的逻辑开始运行。
    3.  **延迟绑定 (如果在用):** 如果使用了延迟绑定，程序在运行时第一次调用某个外部函数时，仍会触发动态链接器的符号解析过程。

    **阶段 6: 程序退出**

    1.  **程序结束:** 当 `main()` 函数返回或调用 `exit()` 系统调用时，程序开始退出过程。
    2.  **运行清理函数:** C 运行时库会调用主程序和所有已加载共享库的清理函数（析构函数），通常通过 `.fini` 节或 `DT_FINI`/`DT_FINI_ARRAY` 指定。
    3.  **进入内核:** 最终调用 `exit()` 或类似的系统调用，再次进入内核空间。
    4.  **内核清理:** 内核回收进程占用的所有资源（内存、文件描述符等）。

    **总结 ELF 装载过程的关键点：**

    *   **内核和用户空间协同:** 加载过程是内核（处理初始文件检查、权限、创建进程地址空间、映射 `PT_LOAD` 段和动态链接器）和用户空间的动态链接器（加载剩余库、执行重定位、运行初始化函数）共同完成的。
    *   **程序头表 (Program Headers):** Loader (内核) 依赖程序头表来决定文件中的哪些部分 (`PT_LOAD` 段) 需要被映射到内存的哪些位置。
    *   **段 vs. 节:** 装载器工作在**段**的层面，而链接器（静态和动态）工作在**节**的层面。程序头表描述的是段，而节头表（Section Headers）主要用于链接、调试和分析，在运行时装载器通常不需要它（尽管 `.dynamic` 段内容指向了需要使用的节信息）。
    *   **内存映射 (mmap):** 加载不是简单地将文件内容读到内存，而是通过 `mmap` 将文件的区域直接映射到进程的虚拟地址空间，实现按需加载和内存共享。
    *   **动态链接器 (ld-linux.so):** 对于动态链接程序，内核只负责加载主程序和动态链接器自身，并将控制权交给动态链接器。动态链接器负责发现、加载所有依赖的共享库，并执行所有符号的重定位。
    *   **Auxiliary Vector (AuxV):** 内核通过 AuxV 将关键信息传递给动态链接器。
    *   **位置无关代码 (PIC):** 对于共享库和 PIE 可执行文件至关重要，因为它允许这些模块被加载到随机地址而无需修改代码段，从而实现多进程共享代码段。
    *   **GOT 和 PLT:** 用于实现对外部函数和数据的间接访问，是 PIC 和动态链接中地址解析的关键机制，尤其支持延迟绑定。
    *   **ASLR:** 影响加载地址，增强安全性，使得 PIC 成为现代系统上的必需品。

    这个过程是一个复杂但高效的机制，它使得动态链接成为可能，实现了资源共享、模块化和灵活的程序更新。

    ## 5. 参考资料
    **本文章源自以下文章内容，仅作学习和记录使用**

    - [ELF结构分析及ElfReader](https://oacia.dev/ElfReader/)
    - [深入浅出 ELF](https://evilpan.com/2020/08/09/elf-inside-out/ "深入浅出 ELF")
    - [ELF文件](https://ctf-wiki.org/executable/elf/structure/basic-info/)
    - 《程序员的自我修养——链接、装载与库》
    - [计算机那些事 (4)——ELF 文件结构](http://chuquan.me/2018/05/21/elf-introduce "计算机那些事 (4)——ELF 文件结构")
    - [计算机那些事 (5)—— 链接、静态链接、动态链接](http://chuquan.me/2018/06/03/linking-static-linking-dynamic-linking/ "计算机那些事 (5)—— 链接、静态链接、动态链接")
    - [计算机那些事 (6)—— 可执行文件的装载与运行](http://chuquan.me/2018/06/17/executable-file-load-and-execution/ "计算机那些事 (6)—— 可执行文件的装载与运行")
